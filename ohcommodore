#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env if present (shell-compatible)
if [[ -f "$SCRIPT_DIR/.env" ]]; then
  set -a
  # shellcheck disable=SC1090
  . "$SCRIPT_DIR/.env"
  set +a
fi

CONFIG_DIR="$HOME/.ohcommodore"
CONFIG_FILE="$CONFIG_DIR/config.json"

log() { printf '==> %s\n' "$*" >&2; }
die() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }

sql_escape() {
  printf '%s' "$1" | sed "s/'/''/g"
}

sql_like_escape() {
  local escaped
  escaped=$(sql_escape "$1")
  printf '%s' "$escaped" | sed -e 's/\\/\\\\/g' -e 's/%/\\%/g' -e 's/_/\\_/g'
}

uuid_gen() {
  uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid
}

# Maildir helpers
maildir_root() { echo "$HOME/Maildir"; }

maildir_for_identity() {
  local identity="$1"
  # Extract local part from identity (e.g., "captain@ship-abc123" -> "ship-abc123")
  local local_part="${identity#*@}"
  echo "$(maildir_root)/$local_part"
}

ensure_maildir() {
  local maildir="$1"
  mkdir -p "$maildir"/{new,cur,tmp}
}

# Remote Maildir helpers (for ships accessing flagship's Maildir)
# Returns 0 if current role requires remote Maildir access
maildir_is_remote() {
  local role
  role=$(get_role)
  [[ "$role" == "captain" ]]
}

# List new message files in Maildir
# Returns list of paths (relative to home on flagship for remote)
maildir_list_new() {
  local maildir="$1"
  if maildir_is_remote; then
    flagship_ssh "ls '$maildir/new/'* 2>/dev/null || true"
  else
    ls "$maildir/new/"* 2>/dev/null || true
  fi
}

# Claim a message (move from new/ to cur/)
# For remote: also copies message locally for processing
# Returns path to local claimed message
maildir_claim() {
  local msg_path="$1" maildir="$2"
  local filename
  filename=$(basename "$msg_path")
  local claimed_name="${filename}:2,S"

  if maildir_is_remote; then
    # Claim on flagship (move to cur/)
    flagship_ssh "mv '$msg_path' '$maildir/cur/$claimed_name'"
    # Copy to local Maildir for processing
    ensure_maildir "$maildir"
    flagship_ssh "cat '$maildir/cur/$claimed_name'" > "$maildir/cur/$claimed_name"
    echo "$maildir/cur/$claimed_name"
  else
    mv "$msg_path" "$maildir/cur/$claimed_name"
    echo "$maildir/cur/$claimed_name"
  fi
}

# Email composition and sending
send_email() {
  local from="$1" to="$2" subject="$3" body="$4"
  shift 4
  # Remaining args are extra headers (key: value format)

  local msg_id date_header
  msg_id="<$(uuid_gen)@${from#*@}>"
  date_header=$(date -R)

  {
    echo "From: $from"
    echo "To: $to"
    echo "Subject: $subject"
    echo "Message-ID: $msg_id"
    echo "Date: $date_header"
    # Add extra headers
    for header in "$@"; do
      echo "$header"
    done
    echo ""
    echo "$body"
  } | sendmail -t

  echo "$msg_id"
}

send_reply() {
  local orig_msg="$1" from="$2" subject="$3" body="$4"
  shift 4

  local orig_msgid orig_from
  orig_msgid=$(grep -i '^Message-ID:' "$orig_msg" | head -1 | sed 's/^[^:]*: *//')
  orig_from=$(grep -i '^From:' "$orig_msg" | head -1 | sed 's/^[^:]*: *//')

  send_email "$from" "$orig_from" "$subject" "$body" \
    "In-Reply-To: $orig_msgid" \
    "References: $orig_msgid" \
    "$@"
}

# Parse email message
email_get_header() {
  local msg="$1" header="$2"
  grep -i "^${header}:" "$msg" | head -1 | sed 's/^[^:]*: *//'
}

email_get_body() {
  local msg="$1"
  # Body starts after first blank line
  sed -n '/^$/,$p' "$msg" | tail -n +2
}

# Portable base64 decode (works on both Linux and macOS)
base64_decode() {
  openssl base64 -d -A
}

generate_ship_id() {
  local repo_name="$1"
  local suffix
  suffix=$(openssl rand -hex 3)  # 6 chars
  echo "${repo_name}-${suffix}"
}

resolve_ship_prefix() {
  local prefix="$1"
  local escaped_prefix
  escaped_prefix=$(sql_like_escape "$prefix")

  local -a matches=()
  local match_line
  if ! while IFS= read -r match_line; do
    matches+=("$match_line")
  done < <(duckdb "$(msg_db)" -csv -noheader "SELECT id FROM ships WHERE id LIKE '${escaped_prefix}%' ESCAPE '\\'" 2>&1); then
    die "Database error looking up ship: ${matches[*]}"
  fi

  local count
  count=${#matches[@]}

  case "$count" in
    0) die "No ship matches '$prefix'" ;;
    1) echo "${matches[0]}" ;;
    *) die "Multiple ships match '$prefix': ${matches[*]}" ;;
  esac
}

lookup_ship_ssh_dest() {
  local ship_id="$1"
  local escaped_id
  escaped_id=$(sql_escape "$ship_id")
  local query="SELECT ssh_dest FROM ships WHERE id = '$escaped_id'"

  local role db_result
  role=$(get_role)
  if [[ "$role" == "commodore" ]]; then
    if ! db_result=$(duckdb "$(msg_db)" -noheader -csv "$query" 2>&1); then
      log "ERROR: Database query failed: $db_result"
      return 1
    fi
  else
    need_flagship
    # Suppress stderr to avoid SSH warnings corrupting result; failures detected via exit code
    if ! db_result=$(flagship_ssh "duckdb ~/.ohcommodore/ns/${OHCOM_NS:-default}/data.duckdb -noheader -csv \"${query}\"" 2>/dev/null); then
      log "ERROR: Flagship database query failed for ship '$ship_id'"
      return 1
    fi
  fi

  [[ -n "$db_result" ]] || return 1
  echo "$db_result"
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

# Namespace helpers
ns() { echo "${OHCOM_NS:-default}"; }
ns_root() { echo "$HOME/.ohcommodore/ns/$(ns)"; }
msg_db() { echo "$(ns_root)/data.duckdb"; }
artifacts_root() { echo "$(ns_root)/artifacts"; }

# Default command timeout: 5 minutes
CMD_TIMEOUT_S="${CMD_TIMEOUT_S:-300}"

init_messages_db() {
  local db
  db="$(msg_db)"
  mkdir -p "$(dirname "$db")"
  duckdb "$db" "
    CREATE TABLE IF NOT EXISTS config (
      key TEXT PRIMARY KEY,
      value TEXT
    );
  "
}

need_flagship() {
  [[ -f "$CONFIG_FILE" ]] || die "No flagship configured. Run: ohcommodore init"
}

flagship() {
  jq -r '.flagship' "$CONFIG_FILE"
}

flagship_ssh() {
  ssh -A "$(flagship)" "$@"
}

get_role() {
  jq -r '.role // "local"' "$CONFIG_DIR/identity.json" 2>/dev/null || echo "local"
}

require_role() {
  local allowed=("$@")
  local current
  current=$(get_role)
  for role in "${allowed[@]}"; do
    [[ "$current" == "$role" ]] && return 0
  done
  die "Command not available for role '$current'. Allowed: ${allowed[*]}"
}

wait_for_ssh() {
  local dest="$1"
  local retries="${2:-60}"
  local delay="${3:-2}"
  local opts='-o StrictHostKeyChecking=accept-new -o BatchMode=yes -o ConnectTimeout=5'

  for ((i=1; i<=retries; i++)); do
    # shellcheck disable=SC2086  # opts needs word splitting
    if ssh $opts "$dest" 'true' >/dev/null 2>&1; then
      return 0
    fi
    log "SSH not ready ($i/$retries)..."
    sleep "$delay"
  done
  return 1
}

deploy_ohcommodore() {
  local dest="$1"
  local src="${2:-$SCRIPT_DIR/ohcommodore}"
  ssh "$dest" 'mkdir -p ~/.local/bin'
  scp -q "$src" "${dest}:~/.local/bin/ohcommodore"
  ssh "$dest" 'chmod +x ~/.local/bin/ohcommodore'
}

upload_init_script() {
  local dest="$1"
  if [[ -n "${INIT_PATH:-}" ]]; then
    [[ -f "$INIT_PATH" ]] || die "INIT_PATH file not found: $INIT_PATH"
    log "Uploading local init script..."
    scp -q "$INIT_PATH" "${dest}:~/.local/bin/init.sh"
    ssh "$dest" 'chmod +x ~/.local/bin/init.sh'
    echo "INIT_PATH=~/.local/bin/init.sh"
  else
    local url="${INIT_URL:-https://raw.githubusercontent.com/smithclay/ohcommodore/main/cloudinit/init.sh}"
    echo "INIT_URL=$(printf %q "$url")"
  fi
}

upload_dotfiles() {
  local dest="$1"
  if [[ -n "${DOTFILES_PATH:-}" ]]; then
    [[ -d "$DOTFILES_PATH" ]] || die "DOTFILES_PATH directory not found: $DOTFILES_PATH"
    log "Uploading local dotfiles..."
    ssh "$dest" "rm -rf ~/.dotfiles"
    scp -rq "$DOTFILES_PATH" "${dest}:~/.dotfiles"
    echo "DOTFILES_PATH=~/.dotfiles"
  elif [[ -n "${DOTFILES_URL:-}" ]]; then
    echo "DOTFILES_URL=$(printf %q "$DOTFILES_URL")"
  fi
}

run_init_script() {
  local role="$1"
  shift
  # Remaining args are extra env vars in KEY=value format
  local env_cmd=(env "GH_TOKEN=${GH_TOKEN:-}" "ROLE=$role" "DOTFILES_PATH=${DOTFILES_PATH:-}" "DOTFILES_URL=${DOTFILES_URL:-}" "$@")
  if [[ -n "${INIT_PATH:-}" ]]; then
    log "Running OS init script (local)..."
    "${env_cmd[@]}" bash "$INIT_PATH"
  elif [[ -n "${INIT_URL:-}" ]]; then
    log "Running OS init script (remote)..."
    curl -fsSL "$INIT_URL" | "${env_cmd[@]}" bash
  fi
}

# Shared VM creation helper - creates VM, waits for SSH, deploys ohcommodore
# Usage: ssh_dest=$(_create_vm "vm-name" [--wait-dns])
# Outputs ssh_dest to stdout, logs to stderr
_create_vm() {
  local vm_name="$1"
  local wait_dns=false
  [[ "${2:-}" == "--wait-dns" ]] && wait_dns=true

  log "Creating VM ($vm_name)..."
  local create_json
  create_json=$(ssh exe.dev new --json --name="$vm_name" --no-email) \
    || die "Failed to create VM"

  local ssh_dest
  ssh_dest=$(echo "$create_json" | jq -r '.ssh_dest // empty')
  [[ -n "$ssh_dest" ]] || die "Failed to get ssh_dest from: $create_json"

  log "VM created: $ssh_dest"

  if [[ "$wait_dns" == true ]]; then
    log "Waiting for DNS..."
    local hostname="${ssh_dest%%:*}"
    for ((i=1; i<=15; i++)); do
      if host "$hostname" >/dev/null 2>&1; then
        log "DNS resolved: $hostname"
        sleep 10  # Extra buffer for DNS to stabilize
        break
      fi
      log "DNS not ready ($i/15)..."
      sleep 3
    done
  else
    log "Waiting for SSH..."
    sleep 5
  fi

  wait_for_ssh "$ssh_dest" || die "SSH never became ready for $ssh_dest"

  log "Deploying ohcommodore..."
  ssh -o StrictHostKeyChecking=accept-new "$ssh_dest" 'true' 2>/dev/null  # Accept host key
  deploy_ohcommodore "$ssh_dest"

  log "Uploading init script and dotfiles..."
  local init_env dotfiles_env
  init_env=$(upload_init_script "$ssh_dest")
  dotfiles_env=$(upload_dotfiles "$ssh_dest")

  # Return ssh_dest and env vars via stdout (caller captures)
  echo "$ssh_dest"
  echo "$init_env"
  echo "$dotfiles_env"
}

cmd_init() {
  require_role local
  need_cmd ssh
  need_cmd jq
  need_cmd scp

  [[ -f "$CONFIG_FILE" ]] && die "Already initialized. Config: $CONFIG_FILE"

  # Generate unique cluster ID
  local cluster_id flagship_vm
  cluster_id="ohcommodore-$(openssl rand -hex 3)"
  flagship_vm="flagship-${cluster_id}"

  # Check for name collision
  local existing_vms
  existing_vms=$(ssh exe.dev ls --json 2>/dev/null | jq -r '.vms[]?.vm_name // empty' || true)
  if echo "$existing_vms" | grep -qx "$flagship_vm"; then
    die "VM '$flagship_vm' already exists (name collision). Please retry."
  fi

  # Create VM and get connection info
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_create_vm "$flagship_vm")
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  # Set up fleet SSH key (flagship-specific)
  log "Setting up fleet SSH key..."
  ssh "$ssh_dest" 'ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519 -q 2>/dev/null || true'
  local flagship_pubkey flagship_privkey
  flagship_pubkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519.pub')
  flagship_privkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519')

  ssh exe.dev ssh-key add "$flagship_pubkey" \
    || log "Warning: Could not add fleet SSH key (may already exist)"
  ssh "$ssh_dest" 'ssh -o StrictHostKeyChecking=accept-new exe.dev whoami >/dev/null 2>&1' || true

  # Run commodore init
  log "Running commodore init on flagship..."
  ssh "$ssh_dest" "$init_env $dotfiles_env ~/.local/bin/ohcommodore _init_commodore"

  # Save local config
  log "Saving local config..."
  mkdir -p "$CONFIG_DIR"
  local cluster_privkey_b64 cluster_pubkey_b64
  cluster_privkey_b64=$(echo "$flagship_privkey" | base64 | tr -d '\n')
  cluster_pubkey_b64=$(echo "$flagship_pubkey" | base64 | tr -d '\n')

  cat > "$CONFIG_FILE" <<EOF
{
  "flagship": "$ssh_dest",
  "flagship_vm": "$flagship_vm",
  "cluster_id": "$cluster_id",
  "cluster_privkey_b64": "$cluster_privkey_b64",
  "cluster_pubkey_b64": "$cluster_pubkey_b64",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

  log "Done! Cluster '$cluster_id' ready at: $ssh_dest"
  log "Run 'ohcommodore fleet status' to verify."
}

cmd_fleet_status() {
  case "$(get_role)" in
    local)
      need_flagship
      flagship_ssh "~/.local/bin/ohcommodore fleet status"
      ;;
    commodore)
      _fleet_status_impl
      ;;
    captain)
      die "Fleet status not available from ships"
      ;;
  esac
}

_fleet_status_impl() {
  echo "FLAGSHIP: $(hostname -f 2>/dev/null || hostname)"
  echo ""

  local ships_data
  ships_data=$(duckdb "$(msg_db)" -noheader -csv "SELECT id, repo, ssh_dest, status FROM ships ORDER BY created_at" 2>/dev/null || echo "")

  if [[ -z "$ships_data" ]]; then
    echo "SHIPS: (none)"
  else
    local ship_count
    ship_count=$(echo "$ships_data" | wc -l | tr -d ' ')

    echo "SHIPS ($ship_count):"
    printf "  %-25s %-20s %-35s %s\n" "SHIP" "REPO" "SSH_DEST" "STATUS"
    echo "$ships_data" | while IFS=',' read -r id repo ssh_dest status; do
      printf "  %-25s %-20s %-35s %s\n" "$id" "$repo" "$ssh_dest" "$status"
    done
  fi
}

cmd_ship_create() {
  local arg="$1"
  [[ -n "$arg" ]] || die "Usage: ohcommodore ship create <owner/repo | name>"

  # Only require GH_TOKEN if creating a ship with a repo
  if [[ "$arg" == */* && -z "${GH_TOKEN:-}" ]]; then
    die "GH_TOKEN env var required when creating a ship with a repo"
  fi

  case "$(get_role)" in
    local)
      need_flagship
      log "Creating ship '$arg' (via flagship)..."
      local init_env dotfiles_env
      init_env=$(upload_init_script "$(flagship)")
      dotfiles_env=$(upload_dotfiles "$(flagship)")
      local gh_token_env=""
      [[ -n "${GH_TOKEN:-}" ]] && gh_token_env="GH_TOKEN=$(printf %q "$GH_TOKEN")"
      flagship_ssh "$gh_token_env $init_env $dotfiles_env ~/.local/bin/ohcommodore ship create $(printf %q "$arg")"
      ;;
    commodore)
      _ship_create_impl "$arg"
      ;;
    captain)
      die "Cannot create ships from a ship"
      ;;
  esac
}

_ship_create_impl() {
  local arg="$1"
  local repo="" name=""

  # Determine if arg is a repo (contains /) or just a name
  if [[ "$arg" == */* ]]; then
    repo="$arg"
    name="${repo##*/}"
    log "Validating repo '$repo' exists..."
    if ! gh repo view "$repo" --json nameWithOwner >/dev/null 2>&1; then
      die "Repository '$repo' not found or not accessible with current token"
    fi
    log "Repo validated: $repo"
  else
    name="$arg"
    log "Creating empty ship '$name' (no repo)"
  fi

  # Generate unique ship ID
  local ship_id
  ship_id=$(generate_ship_id "$name")

  # Use fleet SSH key (all ships share the same key as flagship)
  log "Using fleet SSH key..."
  local cluster_privkey_b64 cluster_pubkey_b64
  cluster_privkey_b64=$(base64 < ~/.ssh/id_ed25519 | tr -d '\n')
  cluster_pubkey_b64=$(base64 < ~/.ssh/id_ed25519.pub | tr -d '\n')

  # Create VM and get connection info
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_create_vm "ship-${ship_id}" --wait-dns)
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  # Register ship in database
  log "Registering ship in ships table..."
  local escaped_id escaped_repo escaped_dest
  escaped_id=$(sql_escape "$ship_id")
  escaped_repo=$(sql_escape "$repo")
  escaped_dest=$(sql_escape "$ssh_dest")

  duckdb "$(msg_db)" "
    INSERT INTO ships (id, repo, ssh_dest, status)
    VALUES ('$escaped_id', '$escaped_repo', '$escaped_dest', 'creating');
  "

  # Run captain init
  log "Running captain init on ship..."
  local flagship_hostname flagship_ssh_dest
  flagship_hostname=$(hostname -f 2>/dev/null || hostname)
  flagship_ssh_dest="exedev@$flagship_hostname"

  local gh_token_env=""
  [[ -n "${GH_TOKEN:-}" && -n "$repo" ]] && gh_token_env="GH_TOKEN=$(printf %q "$GH_TOKEN")"
  ssh "$ssh_dest" \
    "$gh_token_env $init_env $dotfiles_env FLAGSHIP_SSH_DEST=$(printf %q "$flagship_ssh_dest") SHIP_ID=$(printf %q "$ship_id") SHIP_SSH_PRIVKEY_B64=$(printf %q "$cluster_privkey_b64") SHIP_SSH_PUBKEY_B64=$(printf %q "$cluster_pubkey_b64") ~/.local/bin/ohcommodore _init_captain $(printf %q "$repo")"

  # Update ship status to ready
  log "Updating ship status to ready..."
  duckdb "$(msg_db)" "
    UPDATE ships SET status = 'ready' WHERE id = '$escaped_id';
  "

  log "Created ship: $ship_id"
}

cmd_ship_destroy() {
  local prefix="$1"
  [[ -n "$prefix" ]] || die "Usage: ohcommodore ship destroy <prefix>"

  case "$(get_role)" in
    local)
      need_flagship
      log "Destroying ship matching '$prefix' (via flagship)..."
      flagship_ssh "~/.local/bin/ohcommodore ship destroy $(printf %q "$prefix")"
      ;;
    commodore)
      _ship_destroy_impl "$prefix"
      ;;
    captain)
      die "Cannot destroy ships from a ship"
      ;;
  esac
}

_ship_destroy_impl() {
  local prefix="$1"

  # Resolve prefix to ship ID
  local ship_id
  ship_id=$(resolve_ship_prefix "$prefix")

  local escaped_id
  escaped_id=$(sql_escape "$ship_id")

  log "Setting status to destroying..."
  duckdb "$(msg_db)" "UPDATE ships SET status = 'destroying' WHERE id = '$escaped_id'"

  log "Removing VM ship-${ship_id}..."
  timeout 30 ssh exe.dev rm "ship-${ship_id}" || log "Warning: VM removal timed out or failed"

  log "Removing from ships registry..."
  duckdb "$(msg_db)" "DELETE FROM ships WHERE id = '$escaped_id'"

  log "Ship '$ship_id' destroyed."
}

cmd_ship_ssh() {
  need_flagship
  local prefix="$1"
  [[ -n "$prefix" ]] || die "Usage: ohcommodore ship ssh <prefix>"

  local escaped_prefix
  escaped_prefix=$(sql_like_escape "$prefix")

  # Get matching ships
  local matches
  matches=$(flagship_ssh "duckdb ~/.ohcommodore/ns/${OHCOM_NS:-default}/data.duckdb -noheader -csv \"SELECT id, ssh_dest FROM ships WHERE id LIKE '${escaped_prefix}%' ESCAPE '\\'\"" 2>/dev/null)

  local count
  if [[ -z "$matches" ]]; then
    count=0
  else
    count=$(echo "$matches" | wc -l | tr -d ' ')
  fi

  case "$count" in
    0) die "No ship matches '$prefix'" ;;
    1)
      local dest
      dest=$(echo "$matches" | cut -d',' -f2)
      exec ssh -o StrictHostKeyChecking=accept-new "$dest"
      ;;
    *)
      local ids
      ids=$(echo "$matches" | cut -d',' -f1 | tr '\n' ' ')
      die "Multiple ships match '$prefix': $ids"
      ;;
  esac
}

cmd_fleet_sink() {
  local force=false scuttle=false direct=false
  for arg in "$@"; do
    case "$arg" in
      --force) force=true ;;
      --scuttle) scuttle=true ;;
      --direct) direct=true ;;
    esac
  done

  # --direct mode: bypass flagship, remove VMs directly from exe.dev
  # Useful for cleaning up orphaned VMs from crashed/failed runs
  if [[ "$direct" == true ]]; then
    _fleet_sink_direct "$force" "$scuttle"
    return
  fi

  case "$(get_role)" in
    local)
      need_flagship

      # Sink ships on flagship (never pass --scuttle to flagship - we handle it locally)
      local args=""
      [[ "$force" == true ]] && args="$args --force"
      flagship_ssh "~/.local/bin/ohcommodore fleet sink $args"

      if [[ "$scuttle" == true ]]; then
        # Delete flagship VM directly from local (flagship can't delete itself)
        log "Scuttling flagship from local..."
        local flagship_vm cluster_pubkey_b64
        flagship_vm=$(jq -r '.flagship_vm' "$CONFIG_FILE")
        cluster_pubkey_b64=$(jq -r '.cluster_pubkey_b64 // empty' "$CONFIG_FILE")

        log "Removing VM $flagship_vm..."
        timeout 30 ssh exe.dev rm "$flagship_vm" || log "Warning: VM removal timed out or failed"

        # Remove fleet SSH key from exe.dev
        if [[ -n "$cluster_pubkey_b64" ]]; then
          log "Removing fleet SSH key from exe.dev..."
          local cluster_pubkey
          cluster_pubkey=$(echo "$cluster_pubkey_b64" | base64_decode)
          ssh -n exe.dev ssh-key remove "$cluster_pubkey" 2>/dev/null || log "Warning: Could not remove fleet SSH key"
        fi

        log "Fleet decommissioned."
        log "Removing local config..."
        rm -rf "$CONFIG_DIR"
      fi
      ;;
    commodore)
      # On flagship, only sink ships - scuttle is handled by local CLI
      _fleet_sink_impl "$force" false
      ;;
    captain)
      die "Fleet sink not available from ships"
      ;;
  esac
}

# Direct cleanup - bypasses flagship, removes VMs directly from exe.dev
# Used for cleaning up orphaned VMs when flagship is unreachable or state is corrupted
_fleet_sink_direct() {
  local force="$1" scuttle="$2"

  log "Direct cleanup mode: bypassing flagship..."

  # Get all ohcommodore VMs from exe.dev
  local all_vms flagship_vms ship_vms
  all_vms=$(ssh exe.dev ls 2>/dev/null | grep -oE '(flagship|ship)-[a-zA-Z0-9_-]+' || true)
  flagship_vms=$(echo "$all_vms" | grep -E '^flagship-' || true)
  ship_vms=$(echo "$all_vms" | grep -E '^ship-' || true)

  if [[ -z "$all_vms" ]]; then
    log "No ohcommodore VMs found on exe.dev"
  else
    echo "Found VMs to remove:"
    [[ -n "$ship_vms" ]] && while read -r vm; do printf '  - %s\n' "$vm"; done <<< "$ship_vms"
    [[ -n "$flagship_vms" && "$scuttle" == true ]] && while read -r vm; do printf '  - %s\n' "$vm"; done <<< "$flagship_vms"

    if [[ "$force" != true ]]; then
      echo ""
      printf "Type 'sink' to confirm: "
      read -r confirm
      [[ "$confirm" == "sink" ]] || die "Aborted."
    fi

    # Remove ship VMs
    if [[ -n "$ship_vms" ]]; then
      while IFS= read -r vm; do
        [[ -n "$vm" ]] || continue
        log "Removing $vm..."
        ssh -n exe.dev rm "$vm" 2>/dev/null || log "Warning: Failed to remove $vm"
      done <<< "$ship_vms"
    fi

    # Remove flagship VMs if --scuttle
    if [[ "$scuttle" == true && -n "$flagship_vms" ]]; then
      while IFS= read -r vm; do
        [[ -n "$vm" ]] || continue
        log "Scuttling $vm..."
        ssh -n exe.dev rm "$vm" 2>/dev/null || log "Warning: Failed to remove $vm"
      done <<< "$flagship_vms"
    fi
  fi

  # Remove local config
  if [[ -d "$CONFIG_DIR" ]]; then
    log "Removing local config..."
    rm -rf "$CONFIG_DIR"
  fi

  log "Direct cleanup complete."
}

_fleet_sink_impl() {
  local force="$1"
  # Note: scuttle is handled by local CLI, not here

  local ships_data
  ships_data=$(duckdb "$(msg_db)" -noheader -csv "SELECT id, repo FROM ships" 2>/dev/null || echo "")

  if [[ -z "$ships_data" ]]; then
    echo "No ships to sink."
  else
    echo "WARNING: This will destroy all ships:"
    echo "$ships_data" | while IFS=',' read -r id repo; do
      echo "  - $id ($repo)"
    done

    if [[ "$force" != true ]]; then
      echo ""
      printf "Type 'sink' to confirm: "
      read -r confirm
      [[ "$confirm" == "sink" ]] || die "Aborted."
    fi

    while IFS=',' read -r id _repo; do
      log "Sinking $id..."
      _ship_destroy_impl "$id" >/dev/null
    done <<< "$ships_data"
    log "Fleet sunk."
  fi

  echo "Flagship still running."
}

init_common() {
  local identity="$1"
  local db maildir
  db="$(msg_db)"
  maildir=$(maildir_for_identity "$identity")

  # Create Maildir structure
  ensure_maildir "$maildir"

  # Initialize config database
  init_messages_db

  local escaped_identity
  escaped_identity=$(sql_escape "$identity")

  duckdb "$db" "
    INSERT INTO config (key, value) VALUES ('POLL_INTERVAL_SEC', '10')
      ON CONFLICT (key) DO NOTHING;
    INSERT INTO config (key, value) VALUES ('IDENTITY', '$escaped_identity')
      ON CONFLICT (key) DO NOTHING;
  "
}

cmd__init_commodore() {
  log "Initializing commodore identity..."
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_DIR/identity.json" <<'EOF'
{"role":"commodore"}
EOF

  run_init_script commodore

  log "Initializing databases..."
  local flagship_hostname
  flagship_hostname=$(hostname -f 2>/dev/null || hostname)

  # Create common config and v2 queue state
  init_common "commodore@$flagship_hostname"

  # Create ships table (commodore-only)
  duckdb "$(msg_db)" "
    CREATE TABLE IF NOT EXISTS ships (
      id TEXT PRIMARY KEY,
      repo TEXT,
      ssh_dest TEXT NOT NULL,
      status TEXT DEFAULT 'creating',
      created_at TEXT DEFAULT (current_timestamp)
    );
  "

  log "Commodore initialized."
}

cmd__init_captain() {
  local repo="${1:-}"

  log "Initializing captain identity..."
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_DIR/identity.json" <<EOF
{"role":"captain"}
EOF

  if [[ -n "${FLAGSHIP_SSH_DEST:-}" ]]; then
    cat > "$CONFIG_FILE" <<EOF
{
  "flagship": "$FLAGSHIP_SSH_DEST"
}
EOF
  fi

  run_init_script captain \
    "TARGET_REPO=$repo" \
    "SHIP_SSH_PRIVKEY_B64=${SHIP_SSH_PRIVKEY_B64:-}" \
    "SHIP_SSH_PUBKEY_B64=${SHIP_SSH_PUBKEY_B64:-}"

  # Use SHIP_ID for identity (unique ship ID from fleet), with hostname fallback for backward compatibility
  local ship_identity
  if [[ -n "${SHIP_ID:-}" ]]; then
    ship_identity="captain@$SHIP_ID"
  else
    # Fallback for ships initialized without SHIP_ID
    ship_identity="captain@$(hostname -f 2>/dev/null || hostname)"
  fi

  # Create common config and v2 queue state
  init_common "$ship_identity"

  log "Captain initialized${repo:+ for $repo}."
}

cmd_inbox() {
  require_role commodore captain

  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    list) _inbox_list "$@" ;;
    send) _inbox_send "$@" ;;
    read) _inbox_read "$@" ;;
    identity) _inbox_identity ;;
    *) die "Usage: ohcommodore inbox [list|send|read|identity]" ;;
  esac
}

_inbox_list() {
  local status_filter="all"
  if [[ "${1:-}" == "--status" && -n "${2:-}" ]]; then
    status_filter="$2"
  fi

  local my_identity maildir
  my_identity=$(_inbox_identity)
  [[ -n "$my_identity" ]] || die "Cannot determine identity"
  maildir=$(maildir_for_identity "$my_identity")

  printf "%-8s %-40s %-25s %-15s %s\n" "STATUS" "ID" "FROM" "TOPIC" "DATE"
  echo "-------- ---------------------------------------- ------------------------- --------------- --------------------"

  if maildir_is_remote; then
    # Remote Maildir listing - parse on flagship side
    flagship_ssh "
      for dir in '$maildir/new' '$maildir/cur'; do
        [[ -d \"\$dir\" ]] || continue
        if [[ \"\$dir\" == */new ]]; then
          status='unread'
          [[ '$status_filter' == 'done' || '$status_filter' == 'handled' ]] && continue
        else
          status='done'
          [[ '$status_filter' == 'unread' || '$status_filter' == 'pending' ]] && continue
        fi
        for msg in \"\$dir\"/*; do
          [[ -f \"\$msg\" ]] || continue
          msg_id=\$(grep -i '^Message-ID:' \"\$msg\" | head -1 | sed 's/^[^:]*: *//' | tr -d '<>' | cut -c1-38)
          from=\$(grep -i '^From:' \"\$msg\" | head -1 | sed 's/^[^:]*: *//' | cut -c1-25)
          topic=\$(grep -i '^X-Ohcom-Topic:' \"\$msg\" | head -1 | sed 's/^[^:]*: *//')
          date_hdr=\$(grep -i '^Date:' \"\$msg\" | head -1 | sed 's/^[^:]*: *//' | cut -c1-20)
          printf '%-8s %-40s %-25s %-15s %s\n' \"\$status\" \"\$msg_id\" \"\$from\" \"\$topic\" \"\$date_hdr\"
        done
      done
    "
  else
    # Local Maildir listing
    local dir status
    for dir in "$maildir/new" "$maildir/cur"; do
      [[ -d "$dir" ]] || continue

      if [[ "$dir" == */new ]]; then
        status="unread"
        [[ "$status_filter" == "done" || "$status_filter" == "handled" ]] && continue
      else
        status="done"
        [[ "$status_filter" == "unread" || "$status_filter" == "pending" ]] && continue
      fi

      for msg in "$dir"/*; do
        [[ -f "$msg" ]] || continue

        local msg_id from topic date_hdr
        msg_id=$(email_get_header "$msg" "Message-ID" | tr -d '<>' | cut -c1-38)
        from=$(email_get_header "$msg" "From" | cut -c1-25)
        topic=$(email_get_header "$msg" "X-Ohcom-Topic")
        date_hdr=$(email_get_header "$msg" "Date" | cut -c1-20)

        printf "%-8s %-40s %-25s %-15s %s\n" "$status" "$msg_id" "$from" "$topic" "$date_hdr"
      done
    done
  fi
}

_inbox_send() {
  [[ $# -ge 2 ]] || die "Usage: ohcommodore inbox send <recipient> <command>"
  local recipient="$1"
  local command="$2"

  if ! echo "$recipient" | grep -qE '^(captain|commodore)@.+$'; then
    die "Invalid recipient format. Use captain@<ship-id> or commodore@<hostname>"
  fi

  local my_identity request_id
  my_identity=$(_inbox_identity)
  [[ -n "$my_identity" ]] || die "Cannot determine identity"
  request_id=$(uuid_gen)

  local msg_id
  msg_id=$(send_email \
    "$my_identity" \
    "$recipient" \
    "cmd.exec" \
    "$command" \
    "X-Ohcom-Topic: cmd.exec" \
    "X-Ohcom-Request-ID: $request_id")

  echo "Message sent: $request_id -> $recipient"
}

_inbox_read() {
  [[ $# -ge 1 ]] || die "Usage: ohcommodore inbox read <message-id-prefix>"
  local msg_prefix="$1"

  local my_identity maildir
  my_identity=$(_inbox_identity)
  [[ -n "$my_identity" ]] || die "Cannot determine identity"
  maildir=$(maildir_for_identity "$my_identity")

  if maildir_is_remote; then
    # Remote: find and read on flagship
    local found
    found=$(flagship_ssh "
      found=''
      for dir in '$maildir/new' '$maildir/cur'; do
        [[ -d \"\$dir\" ]] || continue
        for msg in \"\$dir\"/*; do
          [[ -f \"\$msg\" ]] || continue
          msg_id=\$(grep -i '^Message-ID:' \"\$msg\" | head -1 | sed 's/^[^:]*: *//')
          if [[ \"\$msg_id\" == *'$msg_prefix'* ]]; then
            found=\"\$msg\"
            break 2
          fi
        done
      done
      [[ -n \"\$found\" ]] || { echo 'ERROR:NOT_FOUND'; exit 1; }
      # If in new/, move to cur/
      if [[ \"\$found\" == */new/* ]]; then
        filename=\$(basename \"\$found\")
        mv \"\$found\" '$maildir/cur/'\"\${filename}:2,S\"
        found='$maildir/cur/'\"\${filename}:2,S\"
      fi
      cat \"\$found\"
    " 2>&1) || true

    if [[ "$found" == "ERROR:NOT_FOUND" ]]; then
      die "No message found matching '$msg_prefix'"
    fi
    echo "$found"
  else
    # Local: find and read
    local found=""
    for dir in "$maildir/new" "$maildir/cur"; do
      [[ -d "$dir" ]] || continue
      for msg in "$dir"/*; do
        [[ -f "$msg" ]] || continue
        local msg_id
        msg_id=$(email_get_header "$msg" "Message-ID")
        if [[ "$msg_id" == *"$msg_prefix"* ]]; then
          found="$msg"
          break 2
        fi
      done
    done

    [[ -n "$found" ]] || die "No message found matching '$msg_prefix'"

    # If in new/, move to cur/ (mark as read)
    if [[ "$found" == */new/* ]]; then
      local filename
      filename=$(basename "$found")
      mv "$found" "$maildir/cur/${filename}:2,S"
      found="$maildir/cur/${filename}:2,S"
    fi

    # Output message content
    cat "$found"
  fi
}

_inbox_identity() {
  local identity
  identity=$(duckdb "$(msg_db)" -noheader -csv "SELECT value FROM config WHERE key = 'IDENTITY'" 2>/dev/null)

  # Ensure we have a valid email-style identity
  if [[ -z "$identity" ]]; then
    local role hostname
    role=$(get_role)
    hostname=$(hostname -f 2>/dev/null || hostname)
    identity="${role}@${hostname}"
  fi

  echo "$identity"
}

cmd__scheduler() {
  require_role commodore captain

  local my_identity maildir poll_interval is_remote
  my_identity=$(_inbox_identity)
  [[ -n "$my_identity" ]] || die "No identity configured"
  maildir=$(maildir_for_identity "$my_identity")
  ensure_maildir "$maildir"

  is_remote="no"
  maildir_is_remote && is_remote="yes"

  poll_interval=$(duckdb "$(msg_db)" -noheader -csv "SELECT value FROM config WHERE key = 'POLL_INTERVAL_SEC'" 2>/dev/null || echo "10")

  trap 'log "Scheduler shutting down"; exit 0' SIGTERM SIGINT

  log "Email scheduler starting for $my_identity (poll: ${poll_interval}s, maildir: $maildir, remote: $is_remote)"

  while true; do
    # Process new mail (uses remote helpers if captain)
    local new_files
    new_files=$(maildir_list_new "$maildir")

    while IFS= read -r msg; do
      [[ -n "$msg" && "$msg" != *"No such file"* ]] || continue

      local topic claimed_msg
      # Claim message (moves to cur/, copies locally if remote)
      claimed_msg=$(maildir_claim "$msg" "$maildir")
      [[ -f "$claimed_msg" ]] || continue

      topic=$(email_get_header "$claimed_msg" "X-Ohcom-Topic")

      case "$topic" in
        cmd.exec)
          _scheduler_handle_cmd_exec "$claimed_msg"
          ;;
        cmd.result)
          _scheduler_handle_cmd_result "$claimed_msg"
          ;;
        *)
          log "Unknown topic '$topic' in message, skipping"
          ;;
      esac
    done <<< "$new_files"

    sleep "$poll_interval"
  done
}

_scheduler_handle_cmd_exec() {
  local msg="$1"

  local cmd request_id source started_at ended_at exit_code
  cmd=$(email_get_body "$msg")
  request_id=$(email_get_header "$msg" "X-Ohcom-Request-ID")
  source=$(email_get_header "$msg" "From")

  [[ -n "$cmd" ]] || { log "Empty command in message, skipping"; return; }

  log "Executing: $cmd"
  started_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  # Create artifact directory for output
  local artifact_dir
  artifact_dir="$(artifacts_root)/${request_id:-$(uuid_gen)}"
  mkdir -p "$artifact_dir"

  # Execute command with timeout, capture output
  set +e
  timeout "$CMD_TIMEOUT_S" bash -c "$cmd" > "$artifact_dir/stdout.txt" 2> "$artifact_dir/stderr.txt"
  exit_code=$?
  set -e

  ended_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  log "Command finished: exit=$exit_code"

  # Send result back to source
  if [[ -n "$source" ]]; then
    local my_identity hostname body
    my_identity=$(_inbox_identity)
    hostname=$(hostname -f 2>/dev/null || hostname)

    body=$(cat << RESULT_EOF
Exit code: $exit_code
Started: $started_at
Ended: $ended_at

--stdout--
${hostname}:${artifact_dir}/stdout.txt

--stderr--
${hostname}:${artifact_dir}/stderr.txt
RESULT_EOF
)

    send_reply "$msg" "$my_identity" "Re: cmd.exec" "$body" \
      "X-Ohcom-Topic: cmd.result" \
      "X-Ohcom-Request-ID: ${request_id:-unknown}" \
      "X-Ohcom-Exit-Code: $exit_code"

    log "Result sent to $source"
  fi
}

_scheduler_handle_cmd_result() {
  local msg="$1"

  local request_id exit_code from
  request_id=$(email_get_header "$msg" "X-Ohcom-Request-ID")
  exit_code=$(email_get_header "$msg" "X-Ohcom-Exit-Code")
  from=$(email_get_header "$msg" "From")

  log "Received result: request=$request_id exit=$exit_code from=$from"
  # Results are stored in Maildir for later inspection
}

show_help() {
  cat <<'HELP'
ohcommodore - lightweight multi-agent control plane

USAGE:
  ohcommodore init                         Bootstrap flagship VM
  ohcommodore fleet status                 Show fleet status
  ohcommodore fleet sink [--force] [--scuttle] [--direct]  Destroy ships
    --scuttle  Also destroy flagship
    --direct   Bypass flagship, remove VMs directly from exe.dev (for orphan cleanup)
  ohcommodore ship create <owner/repo|name> Create ship (repo or empty)
  ohcommodore ship destroy <name>          Destroy a ship
  ohcommodore ship ssh <name>              SSH into a ship
  ohcommodore inbox list [--status <s>]    List inbox messages
  ohcommodore inbox send <rcpt> <cmd>      Send command to recipient
  ohcommodore inbox read <id>              Read and mark handled
  ohcommodore inbox identity               Show this node's identity

HELP
}

case "${1:-help}" in
  -h|--help|help) show_help ;;
  init) cmd_init ;;
  fleet)
    case "${2:-}" in
      status) cmd_fleet_status ;;
      sink|destroy) shift 2; cmd_fleet_sink "$@" ;;
      *) die "Usage: ohcommodore fleet [status|sink|destroy]" ;;
    esac ;;
  ship)
    case "${2:-}" in
      create) cmd_ship_create "${3:-}" ;;
      destroy) cmd_ship_destroy "${3:-}" ;;
      ssh) cmd_ship_ssh "${3:-}" ;;
      *) die "Usage: ohcommodore ship [create|destroy|ssh] <arg>" ;;
    esac ;;
  inbox) shift; cmd_inbox "$@" ;;
  _init_commodore) cmd__init_commodore ;;
  _init_captain) cmd__init_captain "${2:-}" ;;
  _scheduler) cmd__scheduler ;;
  *) die "Unknown command: $1. Run 'ohcommodore help' for usage." ;;
esac
