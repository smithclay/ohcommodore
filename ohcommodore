#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env if present (existing env vars take precedence)
if [[ -f "$SCRIPT_DIR/.env" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        # Skip lines without =
        [[ "$line" != *=* ]] && continue
        # Extract key (everything before first =)
        key="${line%%=*}"
        # Skip if key is empty or already set
        [[ -z "$key" ]] && continue
        [[ -n "${!key+x}" ]] && continue
        # Extract value and remove surrounding quotes
        value="${line#*=}"
        value="${value%\"}"
        value="${value#\"}"
        value="${value%\'}"
        value="${value#\'}"
        export "$key=$value"
    done < "$SCRIPT_DIR/.env"
fi

CONFIG_DIR="$HOME/.ohcommodore"
CONFIG_FILE="$CONFIG_DIR/config.json"

log() { printf '==> %s\n' "$*" >&2; }
die() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }

sql_escape() {
  printf '%s' "$1" | sed "s/'/''/g"
}

uuid_gen() {
  uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

# Namespace helpers (v2 queue system)
ns() { echo "${OHCOM_NS:-default}"; }
ns_root() { echo "$HOME/.ohcommodore/ns/$(ns)"; }
msg_db() { echo "$(ns_root)/data.duckdb"; }
q_root() { echo "$(ns_root)/q"; }
q_inbound() { echo "$(q_root)/inbound"; }
q_incoming() { echo "$(q_inbound)/.incoming"; }
q_dead() { echo "$(q_root)/dead"; }
q_outbound() { echo "$(q_root)/outbound"; }
artifacts_root() { echo "$(ns_root)/artifacts"; }

queue_init_dirs() {
  mkdir -p "$(q_inbound)"
  mkdir -p "$(q_incoming)"
  mkdir -p "$(q_dead)"
  mkdir -p "$(q_outbound)"
  mkdir -p "$(artifacts_root)"
}

init_messages_db() {
  local db
  db="$(msg_db)"
  mkdir -p "$(dirname "$db")"
  duckdb "$db" "
    CREATE TABLE IF NOT EXISTS messages (
      message_id TEXT PRIMARY KEY,
      created_at TIMESTAMP NOT NULL,
      source TEXT NOT NULL,
      dest TEXT NOT NULL,
      topic TEXT NOT NULL,
      job_id TEXT,
      lease_token TEXT,
      payload_json TEXT NOT NULL,
      ingested_at TIMESTAMP DEFAULT current_timestamp,
      handled_at TIMESTAMP
    );
  "
}

write_msg_file() {
  local topic="$1"
  local dest="$2"
  local payload_json="$3"
  local job_id="${4:-}"
  local lease_token="${5:-}"

  local msg_id ts source tmpfile finalfile
  msg_id=$(uuid_gen)
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  source=$(_inbox_identity 2>/dev/null || echo "unknown")

  local outdir
  outdir="$(q_outbound)"
  mkdir -p "$outdir"

  tmpfile="$outdir/msg.${ts//[:-]/}.${msg_id}.json.tmp"
  finalfile="${tmpfile%.tmp}"

  jq -n \
    --arg msg_id "$msg_id" \
    --arg created_at "$ts" \
    --arg source "$source" \
    --arg dest "$dest" \
    --arg topic "$topic" \
    --arg job_id "$job_id" \
    --arg lease_token "$lease_token" \
    --argjson payload "$payload_json" \
    '{
      message_id: $msg_id,
      created_at: $created_at,
      source: $source,
      dest: $dest,
      topic: $topic,
      job_id: (if $job_id == "" then null else $job_id end),
      lease_token: (if $lease_token == "" then null else $lease_token end),
      payload: $payload
    }' > "$tmpfile"

  mv "$tmpfile" "$finalfile"
  echo "$finalfile"
}

deliver_msg_file() {
  local local_path="$1"
  local dest_ssh="$2"
  local max_retries="${3:-3}"

  local filename
  filename=$(basename "$local_path")

  local remote_incoming remote_inbound
  # Use ~ for scp (expands on remote side), $HOME for ssh commands
  remote_incoming="~/.ohcommodore/ns/$(ns)/q/inbound/.incoming"
  remote_inbound="~/.ohcommodore/ns/$(ns)/q/inbound"

  local attempt=1
  local delay=1

  local ssh_opts="-o BatchMode=yes -o StrictHostKeyChecking=accept-new"

  local last_err=""
  while [[ $attempt -le $max_retries ]]; do
    # Ensure remote directories exist
    if last_err=$(ssh $ssh_opts "$dest_ssh" "mkdir -p $remote_incoming $remote_inbound" 2>&1); then
      # SCP to .incoming (staging)
      if last_err=$(scp -q -o StrictHostKeyChecking=accept-new "$local_path" "${dest_ssh}:${remote_incoming}/${filename}" 2>&1); then
        # Atomic rename to publish
        if last_err=$(ssh $ssh_opts "$dest_ssh" "mv ${remote_incoming}/${filename} ${remote_inbound}/${filename}" 2>&1); then
          rm -f "$local_path"
          return 0
        else
          log "Delivery attempt $attempt/$max_retries: mv failed: $last_err"
        fi
      else
        log "Delivery attempt $attempt/$max_retries: scp failed: $last_err"
      fi
    else
      log "Delivery attempt $attempt/$max_retries: ssh mkdir failed: $last_err"
    fi

    sleep "$delay"
    delay=$((delay * 2))
    attempt=$((attempt + 1))
  done

  log "ERROR: Failed to deliver message after $max_retries attempts. Last error: $last_err"
  return 1
}

ingest_queue_file() {
  local file_path="$1"
  local db
  db="$(msg_db)"

  # Parse JSON
  local msg_id created_at source dest topic job_id lease_token payload_json
  msg_id=$(jq -r '.message_id' "$file_path")
  created_at=$(jq -r '.created_at' "$file_path")
  source=$(jq -r '.source' "$file_path")
  dest=$(jq -r '.dest' "$file_path")
  topic=$(jq -r '.topic' "$file_path")
  job_id=$(jq -r '.job_id // empty' "$file_path")
  lease_token=$(jq -r '.lease_token // empty' "$file_path")
  payload_json=$(jq -c '.payload' "$file_path")

  # Escape for SQL
  local esc_msg_id esc_source esc_dest esc_topic esc_job_id esc_lease_token esc_payload
  esc_msg_id=$(sql_escape "$msg_id")
  esc_source=$(sql_escape "$source")
  esc_dest=$(sql_escape "$dest")
  esc_topic=$(sql_escape "$topic")
  esc_job_id=$(sql_escape "$job_id")
  esc_lease_token=$(sql_escape "$lease_token")
  esc_payload=$(sql_escape "$payload_json")

  # Insert with ON CONFLICT for idempotency
  local db_err
  if db_err=$(duckdb "$db" "
    INSERT INTO messages (message_id, created_at, source, dest, topic, job_id, lease_token, payload_json)
    VALUES ('$esc_msg_id', '$created_at', '$esc_source', '$esc_dest', '$esc_topic',
            $([ -n "$job_id" ] && echo "'$esc_job_id'" || echo "NULL"),
            $([ -n "$lease_token" ] && echo "'$esc_lease_token'" || echo "NULL"),
            '$esc_payload')
    ON CONFLICT (message_id) DO NOTHING;
  " 2>&1); then
    # Ack: remove file
    rm -f "$file_path"
  else
    # Deadletter: move to dead queue with reason (include actual error)
    local filename
    filename=$(basename "$file_path")
    mv "$file_path" "$(q_dead)/$filename"
    echo "DuckDB insert failed: $db_err" > "$(q_dead)/${filename%.json}.reason"
    die "Failed to ingest message $msg_id: $db_err"
  fi
}

# Daemon support functions (v2 queue system)
DAEMON_SHUTDOWN=0

daemon_shutdown_handler() {
  log "Shutdown signal received, finishing current work..."
  DAEMON_SHUTDOWN=1
}

daemon_recover_claimed() {
  local inbound claimed_file filename age_seconds threshold_seconds
  inbound="$(q_inbound)"
  threshold_seconds=300  # 5 minutes

  for claimed_file in "$inbound"/.claimed.*.json; do
    [[ -f "$claimed_file" ]] || continue

    filename=$(basename "$claimed_file")
    filename="${filename#.claimed.}"  # Remove .claimed. prefix

    # Get file age in seconds
    if [[ "$(uname)" == "Darwin" ]]; then
      age_seconds=$(( $(date +%s) - $(stat -f %m "$claimed_file") ))
    else
      age_seconds=$(( $(date +%s) - $(stat -c %Y "$claimed_file") ))
    fi

    if [[ $age_seconds -gt $threshold_seconds ]]; then
      # Too old - deadletter
      mv "$claimed_file" "$(q_dead)/$filename"
      echo "Abandoned claim (age: ${age_seconds}s, exceeded ${threshold_seconds}s threshold)" > "$(q_dead)/${filename%.json}.reason"
      log "Deadlettered abandoned claim: $filename"
    else
      # Recent - retry
      mv "$claimed_file" "$inbound/$filename"
      log "Recovered claimed file for retry: $filename"
    fi
  done
}

daemon_claim_one() {
  local inbound file filename claimed_path
  inbound="$(q_inbound)"

  # Find first visible message file
  for file in "$inbound"/msg.*.json; do
    [[ -f "$file" ]] || continue

    filename=$(basename "$file")
    claimed_path="$inbound/.claimed.$filename"

    # Atomic claim via rename
    if mv "$file" "$claimed_path" 2>/dev/null; then
      echo "$claimed_path"
      return 0
    fi
  done

  # No messages to claim
  return 1
}

daemon_exec_cmd() {
  local cmd="$1"
  local cwd="$2"
  local env_json="$3"
  local timeout_s="${4:-1800}"

  local result exit_code

  # Expand ~ in cwd
  cwd="${cwd/#\~/$HOME}"

  # Change to working directory if specified
  if [[ -n "$cwd" && -d "$cwd" ]]; then
    cd "$cwd"
  fi

  # Execute with timeout
  result=$(timeout "$timeout_s" bash -c "$cmd" 2>&1) && exit_code=$? || exit_code=$?

  echo "$result"
  return $exit_code
}

emit_cmd_result() {
  local request_id="$1"
  local exit_code="$2"
  local stdout_path="$3"
  local stderr_path="$4"
  local started_at="$5"
  local ended_at="$6"
  local dest="$7"

  local hostname
  hostname=$(hostname -f 2>/dev/null || hostname)

  # Build paths that include hostname (artifacts stay on ship)
  local remote_stdout_path remote_stderr_path
  remote_stdout_path="${hostname}:${stdout_path}"
  remote_stderr_path="${hostname}:${stderr_path}"

  local payload_json
  payload_json=$(jq -n \
    --arg request_id "$request_id" \
    --argjson exit_code "$exit_code" \
    --arg stdout_path "$remote_stdout_path" \
    --arg stderr_path "$remote_stderr_path" \
    --arg started_at "$started_at" \
    --arg ended_at "$ended_at" \
    '{
      request_id: $request_id,
      exit_code: $exit_code,
      stdout_path: $stdout_path,
      stderr_path: $stderr_path,
      started_at: $started_at,
      ended_at: $ended_at
    }')

  write_msg_file "cmd.result" "$dest" "$payload_json"
}

daemon_process_one() {
  local my_identity="$1"

  # Claim a message
  local claimed_file
  claimed_file=$(daemon_claim_one) || return 1

  # Ingest into database
  local ingest_err
  if ! ingest_err=$(ingest_queue_file "$claimed_file" 2>&1); then
    log "Failed to ingest claimed file: $claimed_file"
    return 1
  fi

  # Escape identity for SQL query (prevent injection)
  local escaped_identity
  escaped_identity=$(sql_escape "$my_identity")

  # Find unhandled cmd.exec messages for us
  local msg_row db_err
  if ! msg_row=$(duckdb "$(msg_db)" -json "
    SELECT message_id, payload_json
    FROM messages
    WHERE dest = '$escaped_identity'
      AND topic = 'cmd.exec'
      AND handled_at IS NULL
    ORDER BY created_at
    LIMIT 1
  " 2>&1); then
    log "ERROR: Failed to query messages database: $msg_row"
    return 1
  fi

  [[ -n "$msg_row" && "$msg_row" != "[]" ]] || return 0

  local msg_id payload_json cmd cwd timeout_s request_id source
  msg_id=$(echo "$msg_row" | jq -r '.[0].message_id')
  payload_json=$(echo "$msg_row" | jq -r '.[0].payload_json')

  # SECURITY NOTE: Commands from inbox are executed without sanitization.
  # This is intentional - the inbox system is designed to execute arbitrary commands.
  # Ensure the inbox queue is only writable by trusted sources (SSH key authentication).
  cmd=$(echo "$payload_json" | jq -r '.cmd')
  cwd=$(echo "$payload_json" | jq -r '.cwd // "~"')
  timeout_s=$(echo "$payload_json" | jq -r '.timeout_s // 1800')
  request_id=$(echo "$payload_json" | jq -r '.request_id // empty')

  # Get source for reply (escape msg_id to prevent SQL injection)
  local escaped_msg_id
  escaped_msg_id=$(sql_escape "$msg_id")
  source=$(duckdb "$(msg_db)" -noheader -csv "SELECT source FROM messages WHERE message_id='$escaped_msg_id'")

  # Create artifact directory
  local artifact_dir started_at ended_at
  artifact_dir="$(artifacts_root)/${request_id:-$msg_id}"
  mkdir -p "$artifact_dir"

  started_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  # Execute command
  local result exit_code
  result=$(daemon_exec_cmd "$cmd" "$cwd" "" "$timeout_s" 2>&1) && exit_code=$? || exit_code=$?

  ended_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  # Save artifacts
  echo "$result" > "$artifact_dir/stdout.txt"
  echo "" > "$artifact_dir/stderr.txt"  # stderr captured in stdout via 2>&1

  # Mark as handled (use escaped_msg_id from earlier)
  duckdb "$(msg_db)" "UPDATE messages SET handled_at = current_timestamp WHERE message_id = '$escaped_msg_id'"

  # Emit result (but don't deliver in this function - let caller handle)
  if [[ -n "$source" ]]; then
    emit_cmd_result \
      "${request_id:-$msg_id}" \
      "$exit_code" \
      "$artifact_dir/stdout.txt" \
      "$artifact_dir/stderr.txt" \
      "$started_at" \
      "$ended_at" \
      "$source" >/dev/null
    # Note: actual delivery would be done by a separate sender loop or inline
  fi

  return 0
}

need_flagship() {
  [[ -f "$CONFIG_FILE" ]] || die "No flagship configured. Run: ohcommodore init"
}

flagship() {
  jq -r '.flagship' "$CONFIG_FILE"
}

flagship_vm() {
  jq -r '.flagship_vm' "$CONFIG_FILE"
}

flagship_ssh() {
  ssh -A "$(flagship)" "$@"
}

get_role() {
  jq -r '.role // "local"' "$CONFIG_DIR/identity.json" 2>/dev/null || echo "local"
}

require_role() {
  local allowed=("$@")
  local current
  current=$(get_role)
  for role in "${allowed[@]}"; do
    [[ "$current" == "$role" ]] && return 0
  done
  die "Command not available for role '$current'. Allowed: ${allowed[*]}"
}

wait_for_ssh() {
  local dest="$1"
  local retries="${2:-30}"
  local delay="${3:-2}"
  local opts='-o StrictHostKeyChecking=accept-new -o BatchMode=yes -o ConnectTimeout=5'

  for ((i=1; i<=retries; i++)); do
    if ssh $opts "$dest" 'true' >/dev/null 2>&1; then
      return 0
    fi
    log "SSH not ready ($i/$retries)..."
    sleep "$delay"
  done
  return 1
}

deploy_ohcommodore() {
  local dest="$1"
  local src="${2:-$SCRIPT_DIR/ohcommodore}"
  ssh "$dest" 'mkdir -p ~/.local/bin'
  scp -q "$src" "${dest}:~/.local/bin/ohcommodore"
  ssh "$dest" 'chmod +x ~/.local/bin/ohcommodore'
}

upload_init_script() {
  local dest="$1"
  if [[ -n "${INIT_PATH:-}" ]]; then
    [[ -f "$INIT_PATH" ]] || die "INIT_PATH file not found: $INIT_PATH"
    log "Uploading local init script..."
    scp -q "$INIT_PATH" "${dest}:~/.local/bin/init.sh"
    ssh "$dest" 'chmod +x ~/.local/bin/init.sh'
    echo "INIT_PATH=~/.local/bin/init.sh"
  else
    local url="${INIT_URL:-https://raw.githubusercontent.com/smithclay/ohcommodore/main/cloudinit/init.sh}"
    echo "INIT_URL=$(printf %q "$url")"
  fi
}

upload_dotfiles() {
  local dest="$1"
  if [[ -n "${DOTFILES_PATH:-}" ]]; then
    [[ -d "$DOTFILES_PATH" ]] || die "DOTFILES_PATH directory not found: $DOTFILES_PATH"
    log "Uploading local dotfiles..."
    ssh "$dest" "rm -rf ~/.dotfiles"
    scp -rq "$DOTFILES_PATH" "${dest}:~/.dotfiles"
    echo "DOTFILES_PATH=~/.dotfiles"
  elif [[ -n "${DOTFILES_URL:-}" ]]; then
    echo "DOTFILES_URL=$(printf %q "$DOTFILES_URL")"
  fi
}

run_init_script() {
  local role="$1"
  shift
  # Remaining args are extra env vars in KEY=value format
  local env_cmd=(env "GH_TOKEN=${GH_TOKEN:-}" "ROLE=$role" "DOTFILES_PATH=${DOTFILES_PATH:-}" "DOTFILES_URL=${DOTFILES_URL:-}" "$@")
  if [[ -n "${INIT_PATH:-}" ]]; then
    log "Running OS init script (local)..."
    "${env_cmd[@]}" bash "$INIT_PATH"
  elif [[ -n "${INIT_URL:-}" ]]; then
    log "Running OS init script (remote)..."
    curl -fsSL "$INIT_URL" | "${env_cmd[@]}" bash
  fi
}

cmd_init() {
  require_role local
  need_cmd ssh
  need_cmd jq
  need_cmd scp

  [[ -n "${GH_TOKEN:-}" ]] || die "GH_TOKEN env var required for flagship init"
  [[ -f "$CONFIG_FILE" ]] && die "Already initialized. Config: $CONFIG_FILE"

  log "Creating flagship VM..."
  create_json=$(ssh exe.dev new --json --name="flagship-ohcommodore" --no-email) \
    || die "Failed to create flagship VM"

  ssh_dest=$(echo "$create_json" | jq -r '.ssh_dest // empty')
  [[ -n "$ssh_dest" ]] || die "Failed to get ssh_dest from: $create_json"

  log "Flagship created: $ssh_dest"
  log "Waiting for SSH..."
  sleep 5

  wait_for_ssh "$ssh_dest" || die "SSH never became ready for $ssh_dest"

  log "Deploying ohcommodore to flagship..."
  deploy_ohcommodore "$ssh_dest"

  log "Setting up flagship SSH key..."
  flagship_pubkey=$(ssh "$ssh_dest" 'ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519 -q 2>/dev/null || true; cat ~/.ssh/id_ed25519.pub')
  ssh exe.dev ssh-key add "$flagship_pubkey" || log "Warning: Could not add flagship SSH key (may already exist)"
  ssh "$ssh_dest" 'ssh -o StrictHostKeyChecking=accept-new exe.dev whoami >/dev/null 2>&1' || true

  local init_env dotfiles_env
  init_env=$(upload_init_script "$ssh_dest")
  dotfiles_env=$(upload_dotfiles "$ssh_dest")

  log "Running commodore init on flagship..."
  ssh "$ssh_dest" \
    "GH_TOKEN=$(printf %q "$GH_TOKEN") $init_env $dotfiles_env ~/.local/bin/ohcommodore _init_commodore"

  log "Saving local config..."
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_FILE" <<EOF
{
  "flagship": "$ssh_dest",
  "flagship_vm": "flagship-ohcommodore",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

  log "Done! Flagship ready at: $ssh_dest"
  log "Run 'ohcommodore fleet status' to verify."
}

cmd_fleet_status() {
  case "$(get_role)" in
    local)
      need_flagship
      flagship_ssh "~/.local/bin/ohcommodore fleet status"
      ;;
    commodore)
      _fleet_status_impl
      ;;
    captain)
      die "Fleet status not available from ships"
      ;;
  esac
}

_fleet_status_impl() {
  echo "FLAGSHIP: $(hostname -f 2>/dev/null || hostname)"
  echo ""

  local fleet_data
  fleet_data=$(duckdb "$(msg_db)" -noheader -csv "SELECT ssh_dest, repo, status, pubkey FROM fleet ORDER BY created_at" 2>/dev/null || echo "")

  if [[ -z "$fleet_data" ]]; then
    echo "SHIPS: (none)"
  else
    local ship_count
    ship_count=$(echo "$fleet_data" | wc -l | tr -d ' ')
    local registered_keys
    registered_keys=$(ssh exe.dev ssh-key list 2>/dev/null || echo "")

    echo "SHIPS ($ship_count):"
    printf "  %-35s %-30s %-10s %s\n" "HOSTNAME" "REPO" "STATUS" "KEY"
    echo "$fleet_data" | while IFS=',' read -r ssh_dest repo status pubkey; do
      local key_status="none"
      if [[ -n "$pubkey" ]]; then
        local key_part
        key_part=$(echo "$pubkey" | awk '{print $1" "$2}')
        if echo "$registered_keys" | grep -qF "$key_part"; then
          key_status="registered"
        else
          key_status="unregistered"
        fi
      fi
      printf "  %-35s %-30s %-10s %s\n" "$ssh_dest" "$repo" "$status" "$key_status"
    done
  fi
}

cmd_ship_create() {
  local arg="$1"
  [[ -n "$arg" ]] || die "Usage: ohcommodore ship create <owner/repo | name>"
  [[ -n "${GH_TOKEN:-}" ]] || die "GH_TOKEN env var required"

  case "$(get_role)" in
    local)
      need_flagship
      log "Creating ship '$arg' (via flagship)..."
      local init_env dotfiles_env
      init_env=$(upload_init_script "$(flagship)")
      dotfiles_env=$(upload_dotfiles "$(flagship)")
      flagship_ssh "GH_TOKEN=$(printf %q "$GH_TOKEN") $init_env $dotfiles_env ~/.local/bin/ohcommodore ship create $(printf %q "$arg")"
      ;;
    commodore)
      _ship_create_impl "$arg"
      ;;
    captain)
      die "Cannot create ships from a ship"
      ;;
  esac
}

_ship_create_impl() {
  local arg="$1"
  local repo="" name=""

  # Determine if arg is a repo (contains /) or just a name
  if [[ "$arg" == */* ]]; then
    repo="$arg"
    name="${repo##*/}"
    log "Validating repo '$repo' exists..."
    if ! gh repo view "$repo" --json nameWithOwner >/dev/null 2>&1; then
      die "Repository '$repo' not found or not accessible with current token"
    fi
    log "Repo validated: $repo"
  else
    name="$arg"
    log "Creating empty ship '$name' (no repo)"
  fi

  log "Generating SSH key for ship..."
  local tmpdir
  tmpdir=$(mktemp -d)
  trap 'rm -rf "${tmpdir:-}"' EXIT
  ssh-keygen -t ed25519 -N "" -f "$tmpdir/ship_key" -q
  local ship_privkey ship_pubkey
  ship_privkey=$(cat "$tmpdir/ship_key")
  ship_pubkey=$(cat "$tmpdir/ship_key.pub")

  log "Registering ship SSH key with exe.dev..."
  ssh exe.dev ssh-key add "$ship_pubkey" || log "Warning: Could not add ship SSH key (may already exist)"

  local ship_privkey_b64 ship_pubkey_b64
  ship_privkey_b64=$(echo "$ship_privkey" | base64 -w0)
  ship_pubkey_b64=$(echo "$ship_pubkey" | base64 -w0)

  log "Creating ship VM..."
  local create_json
  create_json=$(ssh exe.dev new --json \
    --name="ship-${name}" \
    --no-email \
    --env GH_TOKEN="$GH_TOKEN" \
    --env TARGET_REPO="$repo" \
    --env SHIP_SSH_PRIVKEY_B64="$ship_privkey_b64" \
    --env SHIP_SSH_PUBKEY_B64="$ship_pubkey_b64") || true

  local error_msg
  error_msg=$(echo "$create_json" | jq -r '.error // empty')
  [[ -z "$error_msg" ]] || die "VM creation failed: $error_msg"

  local ssh_dest
  ssh_dest=$(echo "$create_json" | jq -r '.ssh_dest')
  [[ -n "$ssh_dest" && "$ssh_dest" != "null" ]] || die "Failed to get ssh_dest from: $create_json"

  log "Ship VM created: $ssh_dest"

  log "Waiting for DNS..."
  local hostname="${ssh_dest%%:*}"
  for ((i=1; i<=15; i++)); do
    if host "$hostname" >/dev/null 2>&1; then
      log "DNS resolved: $hostname"
      sleep 10  # Extra buffer for DNS to stabilize
      break
    fi
    log "DNS not ready ($i/15)..."
    sleep 3
  done

  log "Waiting for SSH..."
  wait_for_ssh "$ssh_dest" || die "SSH never became ready for $ssh_dest"

  log "Deploying ohcommodore to ship..."
  ssh -o StrictHostKeyChecking=accept-new "$ssh_dest" 'true'  # Accept host key
  deploy_ohcommodore "$ssh_dest" ~/.local/bin/ohcommodore

  log "Running captain init on ship..."
  local init_env dotfiles_env
  init_env=$(upload_init_script "$ssh_dest")
  dotfiles_env=$(upload_dotfiles "$ssh_dest")

  ssh "$ssh_dest" \
    "GH_TOKEN=$(printf %q "$GH_TOKEN") $init_env $dotfiles_env SHIP_SSH_PRIVKEY_B64=$(printf %q "$ship_privkey_b64") SHIP_SSH_PUBKEY_B64=$(printf %q "$ship_pubkey_b64") ~/.local/bin/ohcommodore _init_captain $(printf %q "$repo")"

  log "Registering ship in fleet..."
  local escaped_name escaped_repo escaped_dest escaped_pubkey
  escaped_name=$(sql_escape "$name")
  escaped_repo=$(sql_escape "$repo")
  escaped_dest=$(sql_escape "$ssh_dest")
  escaped_pubkey=$(sql_escape "$ship_pubkey")

  duckdb "$(msg_db)" "
    INSERT OR REPLACE INTO fleet (name, repo, ssh_dest, pubkey, status, created_at)
    VALUES ('$escaped_name', '$escaped_repo', '$escaped_dest', '$escaped_pubkey', 'running', current_timestamp);
  "

  log "Ship ready: $ssh_dest"
}

cmd_ship_destroy() {
  local name="$1"
  [[ -n "$name" ]] || die "Usage: ohcommodore ship destroy <name>"

  case "$(get_role)" in
    local)
      need_flagship
      log "Destroying ship '$name' (via flagship)..."
      flagship_ssh "~/.local/bin/ohcommodore ship destroy $(printf %q "$name")"
      ;;
    commodore)
      _ship_destroy_impl "$name"
      ;;
    captain)
      die "Cannot destroy ships from a ship"
      ;;
  esac
}

_ship_destroy_impl() {
  local name="$1"
  local escaped_name
  escaped_name=$(sql_escape "$name")

  local ship_pubkey
  ship_pubkey=$(duckdb "$(msg_db)" -noheader -csv "SELECT pubkey FROM fleet WHERE name = '$escaped_name'" 2>/dev/null || echo "")

  log "Removing VM ship-${name}..."
  timeout 30 ssh exe.dev rm "ship-${name}" || log "Warning: VM removal timed out or failed"

  if [[ -n "$ship_pubkey" ]]; then
    log "Removing ship SSH key from exe.dev..."
    timeout 30 ssh exe.dev ssh-key remove "$ship_pubkey" 2>/dev/null || true
  fi

  log "Removing from fleet registry..."
  duckdb "$(msg_db)" "DELETE FROM fleet WHERE name = '$escaped_name'"

  log "Ship '$name' destroyed."
}

cmd_ship_ssh() {
  need_flagship
  local name="$1"
  [[ -n "$name" ]] || die "Usage: ohcommodore ship ssh <name>"

  local escaped_name dest
  escaped_name=$(sql_escape "$name")
  dest=$(flagship_ssh "duckdb ~/.ohcommodore/ns/${OHCOM_NS:-default}/data.duckdb -noheader -csv \"SELECT ssh_dest FROM fleet WHERE name = '$escaped_name'\"" 2>/dev/null)
  [[ -n "$dest" ]] || die "Ship '$name' not found"

  exec ssh -o StrictHostKeyChecking=accept-new "$dest"
}

cmd_fleet_sink() {
  local force=false scuttle=false
  for arg in "$@"; do
    case "$arg" in
      --force) force=true ;;
      --scuttle) scuttle=true ;;
    esac
  done

  case "$(get_role)" in
    local)
      need_flagship
      local flagship_dest
      flagship_dest=$(jq -r '.flagship' "$CONFIG_FILE")

      # Sink ships on flagship (never pass --scuttle to flagship - we handle it locally)
      local args=""
      [[ "$force" == true ]] && args="$args --force"
      flagship_ssh "~/.local/bin/ohcommodore fleet sink $args"

      if [[ "$scuttle" == true ]]; then
        # Delete flagship VM directly from local (flagship can't delete itself)
        log "Scuttling flagship from local..."
        log "Removing VM flagship-ohcommodore..."
        timeout 30 ssh exe.dev rm "flagship-ohcommodore" || log "Warning: VM removal timed out or failed"
        log "Fleet decommissioned."
        log "Removing local config..."
        rm -rf "$CONFIG_DIR"
      fi
      ;;
    commodore)
      # On flagship, only sink ships - scuttle is handled by local CLI
      _fleet_sink_impl "$force" false
      ;;
    captain)
      die "Fleet sink not available from ships"
      ;;
  esac
}

_fleet_sink_impl() {
  local force="$1"
  # Note: scuttle is handled by local CLI, not here

  local fleet_data
  fleet_data=$(duckdb "$(msg_db)" -noheader -csv "SELECT name, repo FROM fleet" 2>/dev/null || echo "")

  if [[ -z "$fleet_data" ]]; then
    echo "No ships to sink."
  else
    echo "WARNING: This will destroy all ships:"
    echo "$fleet_data" | while IFS=',' read -r name repo; do
      echo "  - $name ($repo)"
    done

    if [[ "$force" != true ]]; then
      echo ""
      printf "Type 'sink' to confirm: "
      read -r confirm
      [[ "$confirm" == "sink" ]] || die "Aborted."
    fi

    echo "$fleet_data" | while IFS=',' read -r name _repo; do
      log "Sinking $name..."
      _ship_destroy_impl "$name" >/dev/null
    done
    log "Fleet sunk."
  fi

  echo "Flagship still running."
}

init_common() {
  local identity="$1"
  local db
  db="$(msg_db)"

  queue_init_dirs
  init_messages_db

  local escaped_identity
  escaped_identity=$(sql_escape "$identity")

  duckdb "$db" "
    CREATE TABLE IF NOT EXISTS config (
      key TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO config (key, value) VALUES ('POLL_INTERVAL_SEC', '10')
      ON CONFLICT (key) DO NOTHING;
    INSERT INTO config (key, value) VALUES ('IDENTITY', '$escaped_identity')
      ON CONFLICT (key) DO NOTHING;
  "
}

cmd__init_commodore() {
  log "Initializing commodore identity..."
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_DIR/identity.json" <<'EOF'
{"role":"commodore"}
EOF

  run_init_script commodore

  log "Initializing databases..."
  local flagship_hostname
  flagship_hostname=$(hostname -f 2>/dev/null || hostname)

  # Create common config and v2 queue state
  init_common "commodore@$flagship_hostname"

  # Create fleet table (commodore-only)
  duckdb "$(msg_db)" "
    CREATE TABLE IF NOT EXISTS fleet (
      name TEXT PRIMARY KEY,
      repo TEXT NOT NULL,
      ssh_dest TEXT NOT NULL,
      pubkey TEXT,
      status TEXT DEFAULT 'running',
      created_at TIMESTAMP DEFAULT current_timestamp
    );
  "

  log "Commodore initialized."
}

cmd__init_captain() {
  local repo="${1:-}"

  log "Initializing captain identity..."
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_DIR/identity.json" <<EOF
{"role":"captain"}
EOF

  # Set up SSH keys if provided via env
  if [[ -n "${SHIP_SSH_PRIVKEY_B64:-}" && -n "${SHIP_SSH_PUBKEY_B64:-}" ]]; then
    log "Installing SSH keys from env..."
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    echo "$SHIP_SSH_PRIVKEY_B64" | base64 -d > ~/.ssh/id_ed25519
    echo "$SHIP_SSH_PUBKEY_B64" | base64 -d > ~/.ssh/id_ed25519.pub
    chmod 600 ~/.ssh/id_ed25519
    chmod 644 ~/.ssh/id_ed25519.pub
  fi

  run_init_script captain \
    "TARGET_REPO=$repo" \
    "SHIP_SSH_PRIVKEY_B64=${SHIP_SSH_PRIVKEY_B64:-}" \
    "SHIP_SSH_PUBKEY_B64=${SHIP_SSH_PUBKEY_B64:-}"

  local ship_hostname
  ship_hostname=$(hostname -f 2>/dev/null || hostname)

  # Create common config and v2 queue state
  init_common "captain@$ship_hostname"

  log "Captain initialized${repo:+ for $repo}."
}

cmd_inbox() {
  require_role commodore captain

  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    list) _inbox_list "$@" ;;
    send) _inbox_send "$@" ;;
    read) _inbox_read "$@" ;;
    identity) _inbox_identity ;;
    *) die "Usage: ohcommodore inbox [list|send|read|identity]" ;;
  esac
}

_inbox_list() {
  local status_filter=""
  if [[ "${1:-}" == "--status" && -n "${2:-}" ]]; then
    case "$2" in
      unread|pending)
        status_filter="WHERE handled_at IS NULL"
        ;;
      done|handled)
        status_filter="WHERE handled_at IS NOT NULL"
        ;;
      *)
        die "Invalid status '$2'. Use: unread, pending, done, handled"
        ;;
    esac
  fi

  [[ -f "$(msg_db)" ]] || die "Messages DB not initialized"
  duckdb "$(msg_db)" -box "
    SELECT
      message_id as id,
      CASE WHEN handled_at IS NULL THEN 'unread' ELSE 'done' END as status,
      source as sender,
      dest as recipient,
      topic,
      substr(payload_json, 1, 50) as payload_preview,
      created_at
    FROM messages
    $status_filter
    ORDER BY created_at DESC
  "
}

_inbox_send() {
  [[ $# -ge 2 ]] || die "Usage: ohcommodore inbox send <recipient> <command>"
  local recipient="$1"
  local command="$2"

  if ! echo "$recipient" | grep -qE '^(captain|commodore)@.+$'; then
    die "Invalid recipient format. Use captain@<hostname> or commodore@<hostname>"
  fi

  local remote_host="${recipient#*@}"
  local dest_ssh="exedev@$remote_host"

  local request_id
  request_id=$(uuid_gen)

  # Build cmd.exec payload
  local payload_json
  payload_json=$(jq -n \
    --arg request_id "$request_id" \
    --arg cmd "$command" \
    '{
      request_id: $request_id,
      cmd: $cmd,
      cwd: "~",
      env: {},
      timeout_s: 1800
    }')

  # Write message file
  local msg_path
  msg_path=$(write_msg_file "cmd.exec" "$recipient" "$payload_json")

  # Deliver via SCP
  if deliver_msg_file "$msg_path" "$dest_ssh"; then
    echo "Message sent: $request_id -> $recipient"
  else
    die "Failed to send message to $recipient"
  fi
}

_inbox_read() {
  [[ $# -ge 1 ]] || die "Usage: ohcommodore inbox read <id>"
  local msg_id="$1"
  local escaped_id
  escaped_id=$(sql_escape "$msg_id")

  [[ -f "$(msg_db)" ]] || die "Messages DB not initialized"
  duckdb "$(msg_db)" "UPDATE messages SET handled_at = current_timestamp WHERE message_id = '$escaped_id' AND handled_at IS NULL"
  duckdb "$(msg_db)" -json "SELECT * FROM messages WHERE message_id = '$escaped_id'"
}

_inbox_identity() {
  duckdb "$(msg_db)" -noheader -csv "SELECT value FROM config WHERE key = 'IDENTITY'" 2>/dev/null
}

cmd__scheduler() {
  require_role commodore captain

  # Initialize v2 queue system
  queue_init_dirs
  init_messages_db

  local poll_interval
  poll_interval=$(duckdb "$(msg_db)" -noheader -csv "SELECT value FROM config WHERE key = 'POLL_INTERVAL_SEC'" 2>/dev/null || echo "10")
  local identity
  identity=$(_inbox_identity)
  [[ -n "$identity" ]] || die "No IDENTITY in config"

  # Set up graceful shutdown
  trap 'daemon_shutdown_handler' SIGTERM SIGINT

  log "v2 Scheduler starting for $identity (poll: ${poll_interval}s)"

  # Recover any abandoned claims from previous crash
  daemon_recover_claimed

  while [[ $DAEMON_SHUTDOWN -eq 0 ]]; do
    # Process all pending messages
    while daemon_process_one "$identity"; do
      [[ $DAEMON_SHUTDOWN -eq 0 ]] || break
    done

    # Send any pending outbound messages
    local outbound_dir result_file dest_host dest_ssh
    outbound_dir="$(q_root)/outbound"
    if [[ -d "$outbound_dir" ]]; then
      for result_file in "$outbound_dir"/*.json; do
        [[ -f "$result_file" ]] || continue
        dest_host=$(jq -r '.dest' "$result_file" | cut -d'@' -f2)
        dest_ssh="exedev@$dest_host"
        deliver_msg_file "$result_file" "$dest_ssh" 3 || {
          log "Warning: Failed to deliver result to $dest_host (see errors above)"
        }
      done
    fi

    sleep "$poll_interval"
  done

  log "Scheduler shutting down gracefully"
}

cmd_queue_status() {
  require_role commodore captain

  queue_init_dirs  # Ensure dirs exist

  local inbound_count claimed_count dead_count msg_count

  inbound_count=$(find "$(q_inbound)" -maxdepth 1 -name 'msg.*.json' 2>/dev/null | wc -l | tr -d ' ')
  claimed_count=$(find "$(q_inbound)" -maxdepth 1 -name '.claimed.*.json' 2>/dev/null | wc -l | tr -d ' ')
  dead_count=$(find "$(q_dead)" -maxdepth 1 -name '*.json' 2>/dev/null | wc -l | tr -d ' ')

  if [[ -f "$(msg_db)" ]]; then
    msg_count=$(duckdb "$(msg_db)" -noheader -csv "SELECT COUNT(*) FROM messages" 2>/dev/null || echo "0")
  else
    msg_count="0"
  fi

  echo "Queue Status (namespace: $(ns))"
  echo "================================"
  echo "  inbound: $inbound_count"
  echo "  claimed: $claimed_count"
  echo "  dead:    $dead_count"
  echo ""
  echo "Database:"
  echo "  messages: $msg_count"
}

show_help() {
  cat <<'HELP'
ohcommodore - lightweight multi-agent control plane

USAGE:
  ohcommodore init                         Bootstrap flagship VM
  ohcommodore fleet status                 Show fleet status
  ohcommodore fleet sink [--force] [--scuttle]  Destroy ships (--scuttle: also flagship)
  ohcommodore ship create <owner/repo|name> Create ship (repo or empty)
  ohcommodore ship destroy <name>          Destroy a ship
  ohcommodore ship ssh <name>              SSH into a ship
  ohcommodore inbox list [--status <s>]    List inbox messages
  ohcommodore inbox send <rcpt> <cmd>      Send command to recipient
  ohcommodore inbox read <id>              Read and mark handled
  ohcommodore inbox identity               Show this node's identity
  ohcommodore queue status               Show v2 queue status

HELP
}

case "${1:-help}" in
  -h|--help|help) show_help ;;
  init) cmd_init ;;
  fleet)
    case "${2:-}" in
      status) cmd_fleet_status ;;
      sink) shift 2; cmd_fleet_sink "$@" ;;
      *) die "Usage: ohcommodore fleet [status|sink]" ;;
    esac ;;
  ship)
    case "${2:-}" in
      create) cmd_ship_create "${3:-}" ;;
      destroy) cmd_ship_destroy "${3:-}" ;;
      ssh) cmd_ship_ssh "${3:-}" ;;
      *) die "Usage: ohcommodore ship [create|destroy|ssh] <arg>" ;;
    esac ;;
  inbox) shift; cmd_inbox "$@" ;;
  queue)
    case "${2:-}" in
      status) cmd_queue_status ;;
      *) die "Usage: ohcommodore queue [status]" ;;
    esac ;;
  _init_commodore) cmd__init_commodore ;;
  _init_captain) cmd__init_captain "${2:-}" ;;
  _scheduler) cmd__scheduler ;;
  *) die "Unknown command: $1. Run 'ohcommodore help' for usage." ;;
esac
