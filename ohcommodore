#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env if present (shell-compatible)
if [[ -f "$SCRIPT_DIR/.env" ]]; then
  set -a
  # shellcheck disable=SC1090
  . "$SCRIPT_DIR/.env"
  set +a
fi

CONFIG_DIR="$HOME/.ohcommodore"
CONFIG_FILE="$CONFIG_DIR/config.json"

log() { printf '==> %s\n' "$*" >&2; }
die() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }

# Get live VM state from exe.dev
exe_dev_ls() {
  ssh exe.dev ls -json 2>/dev/null | jq -c '.vms // []'
}

uuid_gen() {
  uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid
}

# Shell-escape a value for safe embedding in SSH commands
shell_quote() {
  printf '%q' "$1"
}

# NATS helpers
nats_pub() {
  local subject="$1" data="$2"
  nats pub "$subject" "$data" 2>/dev/null
}

nats_req() {
  local subject="$1" data="$2" timeout="${3:-300s}"
  nats req "$subject" "$data" --timeout "$timeout" --raw 2>/dev/null
}

nats_sub() {
  local subject="$1"
  nats sub "$subject" --raw
}

# Portable base64 decode (works on both Linux and macOS)
base64_decode() {
  openssl base64 -d -A
}

generate_ship_id() {
  local repo_name="$1"
  local suffix
  suffix=$(openssl rand -hex 3)  # 6 chars
  echo "${repo_name}-${suffix}"
}

# Resolve ship prefix to full ship ID using exe.dev ls
resolve_ship_prefix() {
  local prefix="$1"
  local vms matches

  vms=$(exe_dev_ls)
  # Extract ship IDs from vm_names like "ship-ohcommodore-abc123" -> "ohcommodore-abc123"
  matches=$(echo "$vms" | jq -r --arg prefix "$prefix" '
    .[] | select(.vm_name | startswith("ship-")) |
    .vm_name | ltrimstr("ship-") |
    select(startswith($prefix))
  ')

  local count
  count=$(echo "$matches" | grep -c . || echo 0)

  case "$count" in
    0) die "No ship matches '$prefix'" ;;
    1) echo "$matches" ;;
    *) die "Multiple ships match '$prefix': $(echo "$matches" | tr '\n' ' ')" ;;
  esac
}

# Get ssh_dest for a ship ID from exe.dev ls
lookup_ship_ssh_dest() {
  local ship_id="$1"
  local vm_name="ship-${ship_id}"

  exe_dev_ls | jq -r --arg vm "$vm_name" '.[] | select(.vm_name == $vm) | .ssh_dest'
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

# Namespace helpers
ns() { echo "${OHCOM_NS:-default}"; }
ns_root() { echo "$HOME/.ohcommodore/ns/$(ns)"; }
ships_json() { echo "$(ns_root)/ships.json"; }
artifacts_root() { echo "$(ns_root)/artifacts"; }

# Default command timeout: 5 minutes
CMD_TIMEOUT_S="${CMD_TIMEOUT_S:-300}"

init_ships_registry() {
  local file
  file="$(ships_json)"
  mkdir -p "$(dirname "$file")"
  [[ -f "$file" ]] || echo '{}' > "$file"
}

need_flagship() {
  [[ -f "$CONFIG_FILE" ]] || die "No flagship configured. Run: ohcommodore init"
}

flagship() {
  jq -r '.flagship' "$CONFIG_FILE"
}

flagship_ssh() {
  ssh -A "$(flagship)" "$@"
}

get_role() {
  jq -r '.role // "local"' "$CONFIG_DIR/identity.json" 2>/dev/null || echo "local"
}

require_role() {
  local allowed=("$@")
  local current
  current=$(get_role)
  for role in "${allowed[@]}"; do
    [[ "$current" == "$role" ]] && return 0
  done
  die "Command not available for role '$current'. Allowed: ${allowed[*]}"
}

wait_for_ssh() {
  local dest="$1"
  local retries="${2:-60}"
  local delay="${3:-2}"
  local opts='-o StrictHostKeyChecking=accept-new -o BatchMode=yes -o ConnectTimeout=5'

  for ((i=1; i<=retries; i++)); do
    # shellcheck disable=SC2086  # opts needs word splitting
    if ssh $opts "$dest" 'true' >/dev/null 2>&1; then
      return 0
    fi
    log "SSH not ready ($i/$retries)..."
    sleep "$delay"
  done
  return 1
}

deploy_ohcommodore() {
  local dest="$1"
  local src="${2:-$SCRIPT_DIR/ohcommodore}"
  ssh "$dest" 'mkdir -p ~/.local/bin'
  scp -q "$src" "${dest}:~/.local/bin/ohcommodore"
  ssh "$dest" 'chmod +x ~/.local/bin/ohcommodore'
}

upload_init_script() {
  local dest="$1"
  if [[ -n "${INIT_PATH:-}" ]]; then
    [[ -f "$INIT_PATH" ]] || die "INIT_PATH file not found: $INIT_PATH"
    log "Uploading local init script..."
    scp -q "$INIT_PATH" "${dest}:~/.local/bin/init.sh"
    ssh "$dest" 'chmod +x ~/.local/bin/init.sh'
    echo "INIT_PATH=~/.local/bin/init.sh"
  else
    local url="${INIT_URL:-https://raw.githubusercontent.com/smithclay/ohcommodore/main/cloudinit/init.sh}"
    echo "INIT_URL=$(printf %q "$url")"
  fi
}

upload_dotfiles() {
  local dest="$1"
  if [[ -n "${DOTFILES_PATH:-}" ]]; then
    [[ -d "$DOTFILES_PATH" ]] || die "DOTFILES_PATH directory not found: $DOTFILES_PATH"
    log "Uploading local dotfiles..."
    ssh "$dest" "rm -rf ~/.dotfiles"
    scp -rq "$DOTFILES_PATH" "${dest}:~/.dotfiles"
    echo "DOTFILES_PATH=~/.dotfiles"
  elif [[ -n "${DOTFILES_URL:-}" ]]; then
    echo "DOTFILES_URL=$(printf %q "$DOTFILES_URL")"
  fi
}

run_init_script() {
  local role="$1"
  shift
  # Remaining args are extra env vars in KEY=value format
  local env_cmd=(env "GH_TOKEN=${GH_TOKEN:-}" "ROLE=$role" "DOTFILES_PATH=${DOTFILES_PATH:-}" "DOTFILES_URL=${DOTFILES_URL:-}" "$@")
  if [[ -n "${INIT_PATH:-}" ]]; then
    log "Running OS init script (local)..."
    "${env_cmd[@]}" bash "$INIT_PATH"
  elif [[ -n "${INIT_URL:-}" ]]; then
    log "Running OS init script (remote)..."
    curl -fsSL "$INIT_URL" | "${env_cmd[@]}" bash
  fi
}

# Shared VM creation helper - creates VM, waits for SSH, deploys ohcommodore
# Usage: ssh_dest=$(_create_vm "vm-name" [--wait-dns])
# Outputs ssh_dest to stdout, logs to stderr
_create_vm() {
  local vm_name="$1"
  local wait_dns=false
  [[ "${2:-}" == "--wait-dns" ]] && wait_dns=true

  log "Creating VM ($vm_name)..."
  local create_json
  create_json=$(ssh exe.dev new --json --name="$vm_name" --no-email) \
    || die "Failed to create VM"

  local ssh_dest
  ssh_dest=$(echo "$create_json" | jq -r '.ssh_dest // empty')
  [[ -n "$ssh_dest" ]] || die "Failed to get ssh_dest from: $create_json"

  log "VM created: $ssh_dest"

  if [[ "$wait_dns" == true ]]; then
    log "Waiting for DNS..."
    local hostname="${ssh_dest%%:*}"
    for ((i=1; i<=15; i++)); do
      if host "$hostname" >/dev/null 2>&1; then
        log "DNS resolved: $hostname"
        sleep 10  # Extra buffer for DNS to stabilize
        break
      fi
      log "DNS not ready ($i/15)..."
      sleep 3
    done
  else
    log "Waiting for SSH..."
    sleep 5
  fi

  wait_for_ssh "$ssh_dest" || die "SSH never became ready for $ssh_dest"

  log "Deploying ohcommodore..."
  ssh -o StrictHostKeyChecking=accept-new "$ssh_dest" 'true' 2>/dev/null  # Accept host key
  deploy_ohcommodore "$ssh_dest"

  log "Uploading init script and dotfiles..."
  local init_env dotfiles_env
  init_env=$(upload_init_script "$ssh_dest")
  dotfiles_env=$(upload_dotfiles "$ssh_dest")

  # Return ssh_dest and env vars via stdout (caller captures)
  echo "$ssh_dest"
  echo "$init_env"
  echo "$dotfiles_env"
}

cmd_init() {
  require_role local
  need_cmd ssh
  need_cmd jq
  need_cmd scp

  [[ -f "$CONFIG_FILE" ]] && die "Already initialized. Config: $CONFIG_FILE"

  # Generate unique cluster ID
  local cluster_id flagship_vm
  cluster_id="ohcommodore-$(openssl rand -hex 3)"
  flagship_vm="flagship-${cluster_id}"

  # Check for name collision
  local existing_vms
  existing_vms=$(ssh exe.dev ls --json 2>/dev/null | jq -r '.vms[]?.vm_name // empty' || true)
  if echo "$existing_vms" | grep -qx "$flagship_vm"; then
    die "VM '$flagship_vm' already exists (name collision). Please retry."
  fi

  # Create VM and get connection info
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_create_vm "$flagship_vm")
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  # Set up fleet SSH key (flagship-specific)
  log "Setting up fleet SSH key..."
  ssh "$ssh_dest" 'ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519 -q 2>/dev/null || true'
  local flagship_pubkey flagship_privkey
  flagship_pubkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519.pub')
  flagship_privkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519')

  ssh exe.dev ssh-key add "$flagship_pubkey" \
    || log "Warning: Could not add fleet SSH key (may already exist)"
  ssh "$ssh_dest" 'ssh -o StrictHostKeyChecking=accept-new exe.dev whoami >/dev/null 2>&1' || true

  # Store Claude token if provided
  if [[ -n "${CLAUDE_CODE_OAUTH_TOKEN:-}" ]]; then
    log "Storing Claude Code token on flagship..."
    ssh "$ssh_dest" "sudo mkdir -p /etc/ohcommodore && printf '%s' $(shell_quote "$CLAUDE_CODE_OAUTH_TOKEN") | sudo tee /etc/ohcommodore/claude_token > /dev/null && sudo chmod 600 /etc/ohcommodore/claude_token"
  fi

  # Run commodore init
  log "Running commodore init on flagship..."
  ssh "$ssh_dest" "$init_env $dotfiles_env ~/.local/bin/ohcommodore _init_commodore"

  # Save local config
  log "Saving local config..."
  mkdir -p "$CONFIG_DIR"
  local cluster_privkey_b64 cluster_pubkey_b64
  cluster_privkey_b64=$(echo "$flagship_privkey" | base64 | tr -d '\n')
  cluster_pubkey_b64=$(echo "$flagship_pubkey" | base64 | tr -d '\n')

  jq -n \
    --arg flagship "$ssh_dest" \
    --arg flagship_vm "$flagship_vm" \
    --arg cluster_id "$cluster_id" \
    --arg privkey "$cluster_privkey_b64" \
    --arg pubkey "$cluster_pubkey_b64" \
    --arg created "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    '{flagship: $flagship, flagship_vm: $flagship_vm, cluster_id: $cluster_id,
      cluster_privkey_b64: $privkey, cluster_pubkey_b64: $pubkey, created_at: $created}' \
    > "$CONFIG_FILE"

  log "Done! Cluster '$cluster_id' ready at: $ssh_dest"
  log "Run 'ohcommodore fleet status' to verify."
}

cmd_fleet_status() {
  case "$(get_role)" in
    local)
      need_flagship
      flagship_ssh "~/.local/bin/ohcommodore fleet status"
      ;;
    commodore)
      _fleet_status_impl
      ;;
    captain)
      die "Fleet status not available from ships"
      ;;
  esac
}

_fleet_status_impl() {
  echo "FLAGSHIP: $(hostname -f 2>/dev/null || hostname)"
  echo ""

  local vms registry
  vms=$(exe_dev_ls)
  registry=$(cat "$(ships_json)" 2>/dev/null || echo '{}')

  # Merge exe.dev ls (live state) with ships.json (repo info)
  local ships_data
  ships_data=$(echo "$vms" | jq -r --argjson reg "$registry" '
    .[] | select(.vm_name | startswith("ship-")) |
    (.vm_name | ltrimstr("ship-")) as $id |
    [$id, ($reg[$id].repo // "-"), .ssh_dest, .status]
    | @tsv
  ' 2>/dev/null | sort)

  if [[ -z "$ships_data" ]]; then
    echo "SHIPS: (none)"
  else
    local ship_count
    ship_count=$(echo "$ships_data" | grep -c . || echo 0)

    echo "SHIPS ($ship_count):"
    {
      echo "SHIP	REPO	SSH_DEST	STATUS"
      echo "$ships_data"
    } | column -t -s $'\t' | sed 's/^/  /'
  fi
}

cmd_ship_create() {
  local arg="$1"
  [[ -n "$arg" ]] || die "Usage: ohcommodore ship create <owner/repo | name>"

  # Only require GH_TOKEN if creating a ship with a repo
  if [[ "$arg" == */* && -z "${GH_TOKEN:-}" ]]; then
    die "GH_TOKEN env var required when creating a ship with a repo"
  fi

  case "$(get_role)" in
    local)
      need_flagship
      log "Creating ship '$arg' (via flagship)..."
      local init_env dotfiles_env
      init_env=$(upload_init_script "$(flagship)")
      dotfiles_env=$(upload_dotfiles "$(flagship)")
      local gh_token_env=""
      [[ -n "${GH_TOKEN:-}" ]] && gh_token_env="GH_TOKEN=$(printf %q "$GH_TOKEN")"
      flagship_ssh "$gh_token_env $init_env $dotfiles_env ~/.local/bin/ohcommodore ship create $(printf %q "$arg")"
      ;;
    commodore)
      _ship_create_impl "$arg"
      ;;
    captain)
      die "Cannot create ships from a ship"
      ;;
  esac
}

# Ship registry helpers (JSON-based)
_register_ship() {
  local ship_id="$1" repo="$2"
  local file
  file="$(ships_json)"
  local tmp="${file}.tmp"
  jq --arg id "$ship_id" --arg repo "$repo" '.[$id] = {repo: $repo}' "$file" > "$tmp" && mv "$tmp" "$file"
}

_ship_create_impl() {
  local arg="$1"
  local repo="" name=""

  # Determine if arg is a repo (contains /) or just a name
  if [[ "$arg" == */* ]]; then
    repo="$arg"
    name="${repo##*/}"
    log "Validating repo '$repo' exists..."
    gh repo view "$repo" --json nameWithOwner >/dev/null 2>&1 \
      || die "Repository '$repo' not found or not accessible with current token"
    log "Repo validated: $repo"
  else
    name="$arg"
    log "Creating empty ship '$name' (no repo)"
  fi

  local ship_id
  ship_id=$(generate_ship_id "$name")

  # Get fleet SSH key
  log "Using fleet SSH key..."
  local privkey_b64 pubkey_b64
  privkey_b64=$(base64 < ~/.ssh/id_ed25519 | tr -d '\n')
  pubkey_b64=$(base64 < ~/.ssh/id_ed25519.pub | tr -d '\n')

  # Create VM
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_create_vm "ship-${ship_id}" --wait-dns)
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  log "Registering ship..."
  _register_ship "$ship_id" "$repo"

  # Build init environment
  log "Running captain init on ship..."
  local flagship_host init_args
  flagship_host="exedev@$(hostname -f 2>/dev/null || hostname)"

  init_args="$init_env $dotfiles_env"
  init_args="$init_args FLAGSHIP_SSH_DEST=$(printf %q "$flagship_host")"
  init_args="$init_args SHIP_ID=$(printf %q "$ship_id")"
  init_args="$init_args SHIP_SSH_PRIVKEY_B64=$(printf %q "$privkey_b64")"
  init_args="$init_args SHIP_SSH_PUBKEY_B64=$(printf %q "$pubkey_b64")"
  [[ -n "${GH_TOKEN:-}" && -n "$repo" ]] && init_args="GH_TOKEN=$(printf %q "$GH_TOKEN") $init_args"

  ssh "$ssh_dest" "$init_args ~/.local/bin/ohcommodore _init_captain $(printf %q "$repo")"

  log "Created ship: $ship_id"
}

cmd_ship_destroy() {
  local prefix="$1"
  [[ -n "$prefix" ]] || die "Usage: ohcommodore ship destroy <prefix>"

  case "$(get_role)" in
    local)
      need_flagship
      log "Destroying ship matching '$prefix' (via flagship)..."
      flagship_ssh "~/.local/bin/ohcommodore ship destroy $(printf %q "$prefix")"
      ;;
    commodore)
      _ship_destroy_impl "$prefix"
      ;;
    captain)
      die "Cannot destroy ships from a ship"
      ;;
  esac
}

_ship_destroy_impl() {
  local prefix="$1"
  local ship_id
  ship_id=$(resolve_ship_prefix "$prefix")

  _remove_exe_vm "ship-${ship_id}"
  _delete_ship "$ship_id"

  log "Ship '$ship_id' destroyed."
}

_delete_ship() {
  local ship_id="$1"
  local file
  file="$(ships_json)"
  local tmp="${file}.tmp"
  jq --arg id "$ship_id" 'del(.[$id])' "$file" > "$tmp" && mv "$tmp" "$file"
}

cmd_ship_ssh() {
  local prefix="$1"
  [[ -n "$prefix" ]] || die "Usage: ohcommodore ship ssh <prefix>"

  case "$(get_role)" in
    local)
      need_flagship
      # Delegate to flagship's resolver
      local result
      result=$(flagship_ssh "~/.local/bin/ohcommodore _ship_resolve $(shell_quote "$prefix")") \
        || die "No ship matches '$prefix'"
      exec ssh -o StrictHostKeyChecking=accept-new "$result"
      ;;
    commodore)
      local dest
      dest=$(_ship_resolve "$prefix")
      exec ssh -o StrictHostKeyChecking=accept-new "$dest"
      ;;
    captain)
      die "Cannot SSH to ships from a ship"
      ;;
  esac
}

# Internal: resolve ship prefix to ssh_dest (runs on flagship)
cmd__ship_resolve() {
  local prefix="$1"
  [[ -n "$prefix" ]] || die "Usage: _ship_resolve <prefix>"

  local ship_id ssh_dest
  ship_id=$(resolve_ship_prefix "$prefix")
  ssh_dest=$(lookup_ship_ssh_dest "$ship_id") || die "Ship '$ship_id' has no ssh_dest"
  echo "$ssh_dest"
}

_ship_resolve() {
  cmd__ship_resolve "$@"
}

# Shared helpers for fleet sink
_confirm_sink() {
  local force="$1"
  [[ "$force" == true ]] && return 0
  echo ""
  printf "Type 'sink' to confirm: "
  read -r confirm
  [[ "$confirm" == "sink" ]] || die "Aborted."
}

_remove_exe_vm() {
  local vm="$1" label="${2:-Removing}"
  log "$label $vm..."
  timeout 30 ssh -n exe.dev rm "$vm" 2>/dev/null || log "Warning: Failed to remove $vm"
}

cmd_fleet_sink() {
  local force=false scuttle=false
  for arg in "$@"; do
    case "$arg" in
      --force) force=true ;;
      --scuttle) scuttle=true ;;
    esac
  done

  _fleet_sink_direct "$force" "$scuttle"
}

_fleet_sink_direct() {
  local force="$1" scuttle="$2"
  log "Direct cleanup mode: bypassing flagship..."

  local all_vms ship_vms flagship_vms
  all_vms=$(ssh exe.dev ls 2>/dev/null | grep -oE '(flagship|ship)-[a-zA-Z0-9_-]+' || true)
  ship_vms=$(echo "$all_vms" | grep -E '^ship-' || true)
  flagship_vms=$(echo "$all_vms" | grep -E '^flagship-' || true)

  if [[ -z "$ship_vms" && ( -z "$flagship_vms" || "$scuttle" != true ) ]]; then
    log "No ohcommodore VMs to remove"
  else
    echo "VMs to remove:"
    [[ -n "$ship_vms" ]] && echo "$ship_vms" | while read -r vm; do [[ -n "$vm" ]] && echo "  - $vm"; done
    [[ -n "$flagship_vms" && "$scuttle" == true ]] && echo "$flagship_vms" | while read -r vm; do [[ -n "$vm" ]] && echo "  - $vm"; done

    _confirm_sink "$force"

    [[ -n "$ship_vms" ]] && echo "$ship_vms" | while read -r vm; do [[ -n "$vm" ]] && _remove_exe_vm "$vm"; done
    [[ -n "$flagship_vms" && "$scuttle" == true ]] && echo "$flagship_vms" | while read -r vm; do [[ -n "$vm" ]] && _remove_exe_vm "$vm" "Scuttling"; done
  fi

  [[ -d "$CONFIG_DIR" ]] && { log "Removing local config..."; rm -rf "$CONFIG_DIR"; }
  log "Direct cleanup complete."
}

cmd__init_commodore() {
  log "Initializing commodore identity..."
  mkdir -p "$CONFIG_DIR"
  jq -n '{role: "commodore"}' > "$CONFIG_DIR/identity.json"

  run_init_script commodore

  log "Initializing ships registry..."
  init_ships_registry

  log "Commodore initialized."
}

cmd__init_captain() {
  local repo="${1:-}"

  log "Initializing captain identity..."
  mkdir -p "$CONFIG_DIR"
  jq -n '{role: "captain"}' > "$CONFIG_DIR/identity.json"

  if [[ -n "${FLAGSHIP_SSH_DEST:-}" ]]; then
    jq -n --arg flagship "$FLAGSHIP_SSH_DEST" '{flagship: $flagship}' > "$CONFIG_FILE"
  fi

  run_init_script captain \
    "TARGET_REPO=$repo" \
    "SHIP_SSH_PRIVKEY_B64=${SHIP_SSH_PRIVKEY_B64:-}" \
    "SHIP_SSH_PUBKEY_B64=${SHIP_SSH_PUBKEY_B64:-}"

  # Use SHIP_ID for identity (unique ship ID from fleet), with hostname fallback for backward compatibility
  local ship_identity
  if [[ -n "${SHIP_ID:-}" ]]; then
    ship_identity="captain@$SHIP_ID"
  else
    # Fallback for ships initialized without SHIP_ID
    ship_identity="captain@$(hostname -f 2>/dev/null || hostname)"
  fi

  # Create common config
  init_common "$ship_identity"

  log "Captain initialized${repo:+ for $repo}."
}

cmd_inbox() {
  require_role commodore captain

  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    send) _inbox_send "$@" ;;
    identity) _inbox_identity ;;
    *) die "Usage: ohcommodore inbox [send|identity]" ;;
  esac
}

_inbox_send() {
  [[ $# -ge 2 ]] || die "Usage: ohcommodore inbox send <recipient> <command>"
  local recipient="$1"
  local command="$2"

  local subject request_id payload

  if echo "$recipient" | grep -qE '^captain@.+$'; then
    subject="ohcom.cmd.${recipient#captain@}"
  elif [[ "$recipient" == "commodore@flagship" ]]; then
    subject="ohcom.cmd.commodore"
  else
    die "Invalid recipient format. Use captain@<ship-id> or commodore@flagship"
  fi

  request_id=$(uuid_gen)
  payload=$(jq -nc --arg cmd "$command" --arg req "$request_id" \
    '{cmd: $cmd, request_id: $req}')

  nats_pub "$subject" "$payload"
  echo "Message sent: $request_id -> $recipient"
}

_inbox_identity() {
  local role hostname
  role=$(get_role)
  hostname=$(hostname -f 2>/dev/null || hostname)
  echo "${role}@${hostname}"
}

cmd__scheduler() {
  require_role commodore captain

  local my_identity my_role subject
  my_identity=$(_inbox_identity)
  [[ -n "$my_identity" ]] || die "No identity configured"

  # Determine subscription subject based on role
  my_role="${my_identity%%@*}"
  if [[ "$my_role" == "commodore" ]]; then
    subject="ohcom.cmd.commodore"
  else
    # Extract ship ID from identity (e.g., "captain@ship-abc123" -> "ship-abc123")
    subject="ohcom.cmd.${my_identity#*@}"
  fi

  trap 'log "Scheduler shutting down"; exit 0' SIGTERM SIGINT

  log "NATS scheduler starting for $my_identity (subject: $subject)"

  # Subscribe to NATS subject and process messages
  nats_sub "$subject" | while IFS= read -r msg; do
    [[ -n "$msg" ]] || continue

    local cmd request_id
    cmd=$(echo "$msg" | jq -r '.cmd // empty')
    request_id=$(echo "$msg" | jq -r '.request_id // empty')

    [[ -n "$cmd" ]] || { log "Empty or invalid command in message, skipping"; continue; }

    _scheduler_handle_cmd_exec "$cmd" "$request_id"
  done
}

_scheduler_handle_cmd_exec() {
  local cmd="$1" request_id="$2"

  log "Executing: $cmd"

  # Create artifact directory for output
  local artifact_dir exit_code
  artifact_dir="$(artifacts_root)/${request_id:-$(uuid_gen)}"
  mkdir -p "$artifact_dir"

  # Execute command with timeout, capture output
  set +e
  timeout "$CMD_TIMEOUT_S" bash -c "$cmd" > "$artifact_dir/stdout.txt" 2> "$artifact_dir/stderr.txt"
  exit_code=$?
  set -e

  log "Command finished: exit=$exit_code, artifacts: $artifact_dir"
}

show_help() {
  cat <<'HELP'
ohcommodore - lightweight multi-agent control plane

USAGE:
  ohcommodore init                         Bootstrap flagship VM
  ohcommodore fleet status                 Show fleet status
  ohcommodore fleet sink [--force] [--scuttle]  Destroy ships
    --scuttle  Also destroy flagship
  ohcommodore ship create <owner/repo|name> Create ship (repo or empty)
  ohcommodore ship destroy <name>          Destroy a ship
  ohcommodore ship ssh <name>              SSH into a ship
  ohcommodore inbox send <rcpt> <cmd>      Send command (captain@<ship-id> or commodore@flagship)
  ohcommodore inbox identity               Show this node's identity

HELP
}

case "${1:-help}" in
  -h|--help|help) show_help ;;
  init) cmd_init ;;
  fleet)
    case "${2:-}" in
      status) cmd_fleet_status ;;
      sink|destroy) shift 2; cmd_fleet_sink "$@" ;;
      *) die "Usage: ohcommodore fleet [status|sink|destroy]" ;;
    esac ;;
  ship)
    case "${2:-}" in
      create) cmd_ship_create "${3:-}" ;;
      destroy) cmd_ship_destroy "${3:-}" ;;
      ssh) cmd_ship_ssh "${3:-}" ;;
      *) die "Usage: ohcommodore ship [create|destroy|ssh] <arg>" ;;
    esac ;;
  inbox) shift; cmd_inbox "$@" ;;
  _init_commodore) cmd__init_commodore ;;
  _init_captain) cmd__init_captain "${2:-}" ;;
  _ship_resolve) cmd__ship_resolve "${2:-}" ;;
  _scheduler) cmd__scheduler ;;
  *) die "Unknown command: $1. Run 'ohcommodore help' for usage." ;;
esac
